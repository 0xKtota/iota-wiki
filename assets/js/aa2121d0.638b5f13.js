"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[90068],{43315:function(t,e,n){n.r(e),n.d(e,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return m},toc:function(){return l},default:function(){return p}});var a=n(74034),r=n(79973),o=(n(67294),n(3905)),s=["components"],i={keywords:["Rust","WASM","memory space","smart contract state","API","Access","store","state"],description:"The Iota Smart Contracts Protocol (ISCP) provides  a very flexible way of programming smart contracts by providing an API to a sandboxed environment that allows you to interact with the ISCP deterministically without any security risks.",image:"/img/schema_tool/IscpHost.png"},c="Smart Contract Schemas for ISCP",m={unversionedId:"guide/schema/intro",id:"guide/schema/intro",isDocsHomePage:!1,title:"Smart Contract Schemas for ISCP",description:"The Iota Smart Contracts Protocol (ISCP) provides  a very flexible way of programming smart contracts by providing an API to a sandboxed environment that allows you to interact with the ISCP deterministically without any security risks.",source:"@site/external/wasp/documentation/docs/guide/schema/intro.mdx",sourceDirName:"guide/schema",slug:"/guide/schema/intro",permalink:"/wasp/guide/schema/intro",tags:[],version:"current",frontMatter:{keywords:["Rust","WASM","memory space","smart contract state","API","Access","store","state"],description:"The Iota Smart Contracts Protocol (ISCP) provides  a very flexible way of programming smart contracts by providing an API to a sandboxed environment that allows you to interact with the ISCP deterministically without any security risks.",image:"/img/schema_tool/IscpHost.png"},sidebar:"tutorialSidebar",previous:{title:"Rust/Wasm Based Smart Contracts",permalink:"/wasp/guide/rust_wasm/introduction"},next:{title:"Data Access Proxies",permalink:"/wasp/guide/schema/proxies"}},l=[],u={toc:l};function p(t){var e=t.components,i=(0,r.Z)(t,s);return(0,o.kt)("wrapper",(0,a.Z)({},u,i,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"smart-contract-schemas-for-iscp"},"Smart Contract Schemas for ISCP"),(0,o.kt)("p",null,"The Iota Smart Contracts Protocol (ISCP) provides  a very flexible way of\nprogramming smart contracts by providing an API to a sandboxed environment\nthat allows you to interact with the ISCP deterministically without any security risks.\nThe API provides a generic way to store, access, and modify the state of the smart\ncontract. The API can be used by any kind of Virtual Machine (VM) to implement a system to\nprogram, load, and run smart contracts on top of the ISCP. The actual VMs can be\nimplemented by whoever wants to create them."),(0,o.kt)("p",null,(0,o.kt)("a",{target:"_blank",href:n(49664).Z},(0,o.kt)("img",{alt:"Wasp node ISCP Host",src:n(19237).Z}))),(0,o.kt)("p",null,"Of course, we provide an example implementation of such a VM to allow anyone to get\na taste of what it is like to program a smart contract for the ISCP. Our VM implementation\nuses ",(0,o.kt)("a",{parentName:"p",href:"https://webassembly.org/"},"WebAssembly")," (Wasm) code as an intermediate compilation\ntarget. The implementation of the Wasm VM currently uses the open-source ",(0,o.kt)("a",{parentName:"p",href:"https://wasmtime.dev/"},"Wasmtime")," runtime\nenvironment. This enables dynamically loading and running of the Wasm code."),(0,o.kt)("p",null,"We chose Wasm to be able to program smart contracts from any language. Since more and more\nlanguages are becoming capable of generating the intermediate Wasm code this will\neventually allow developers to choose a language they are familiar with."),(0,o.kt)("p",null,"Because each Wasm code unit runs in its own memory space and cannot access anything\noutside that memory by design, Wasm code is ideally suited for secure smart contracts. The\nWasm runtime system will only provide access to external functionality that is needed for\nthe smart contracts to be able to do their thing, but nothing more. In our case, all we do\nis provide access to the ISCP host's sandbox API environment. The way we do that is by\nproviding a simple library that can be linked to the Wasm code. This library, for\nobvious reasons, has been named ",(0,o.kt)("inlineCode",{parentName:"p"},"WasmLib")," for now."),(0,o.kt)("p",null,(0,o.kt)("a",{target:"_blank",href:n(76751).Z},(0,o.kt)("img",{alt:"Wasm VM",src:n(94683).Z}))),(0,o.kt)("p",null,"As you can see we can have any number of smart contracts running in our Wasm VM. Each\nsmart contract is a separately compiled Wasm code unit that contains its own copy of\nWasmLib embedded into it. Each WasmLib provides the ISCP sandbox functionality to its\ncorresponding smart contract and knows how to access the underlying smart contract state\nstorage through the VM runtime system. This makes ISCP sandbox API access seamless to the\nsmart contract by hiding the details of bridging the gap between the smart contract's\nmemory space, and the ISCP host's memory space. It also prevents the smart contract from\naccessing and/or modifying the ISCP host's memory space directly."),(0,o.kt)("p",null,"The ISCP sandbox environment enables the following functionality:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Access to smart contract metadata"),(0,o.kt)("li",{parentName:"ul"},"Access to parameter data for smart contract function calls"),(0,o.kt)("li",{parentName:"ul"},"Access to the smart contract state data"),(0,o.kt)("li",{parentName:"ul"},"A way to return result data to the caller of a smart contract function"),(0,o.kt)("li",{parentName:"ul"},"Access to tokens owned by the smart contract, and the ability to move them"),(0,o.kt)("li",{parentName:"ul"},"Ability to call other smart contract functions"),(0,o.kt)("li",{parentName:"ul"},"Access to logging functionality"),(0,o.kt)("li",{parentName:"ul"},"Access to several utility functions provided by the host")),(0,o.kt)("p",null,"The initial implementation of WasmLib has been created for the Rust programming language.\nRust had the most advanced and stable support for generating Wasm code at the time when we\nstarted implementing our Wasm VM environment. In the meantime, we have also implemented a\nfully functional ",(0,o.kt)("a",{parentName:"p",href:"https://tinygo.org/"},"TinyGo")," version."),(0,o.kt)("p",null,"Both implementations are implemented using only a very small common subset of\nthese languages. This keeps the coding style very similar, barring some syntactic\nidiosyncrasies. The reason for this is that we wanted to make it as easy as possible for\nanyone to start working with our smart contract system. If you have any previous\nexperience in any C-style language you should quickly feel comfortable writing smart\ncontracts in either language, without having to dive deeply into all aspects of the chosen\nlanguage."),(0,o.kt)("p",null,"Let's start by diving deeper into a concept that is central to WasmLib smart contract\nprogramming: ",(0,o.kt)("a",{parentName:"p",href:"/wasp/guide/schema/proxies"},"proxy objects"),"."))}p.isMDXComponent=!0},3905:function(t,e,n){n.d(e,{Zo:function(){return l},kt:function(){return d}});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function o(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?o(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function i(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},o=Object.keys(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(a=0;a<o.length;a++)n=o[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var c=a.createContext({}),m=function(t){var e=a.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},l=function(t){var e=m(t.components);return a.createElement(c.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},p=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,o=t.originalType,c=t.parentName,l=i(t,["components","mdxType","originalType","parentName"]),p=m(n),d=r,h=p["".concat(c,".").concat(d)]||p[d]||u[d]||o;return n?a.createElement(h,s(s({ref:e},l),{},{components:n})):a.createElement(h,s({ref:e},l))}));function d(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=n.length,s=new Array(o);s[0]=p;var i={};for(var c in e)hasOwnProperty.call(e,c)&&(i[c]=e[c]);i.originalType=t,i.mdxType="string"==typeof t?t:r,s[1]=i;for(var m=2;m<o;m++)s[m]=n[m];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},49664:function(t,e,n){e.Z=n.p+"assets/files/IscpHost-2c38378f3efce33c5a99978bfd26cc46.png"},76751:function(t,e,n){e.Z=n.p+"assets/files/WasmVM-9d5cb20cbfde79b2cca6826072145a71.png"},19237:function(t,e,n){e.Z=n.p+"assets/images/IscpHost-2c38378f3efce33c5a99978bfd26cc46.png"},94683:function(t,e,n){e.Z=n.p+"assets/images/WasmVM-9d5cb20cbfde79b2cca6826072145a71.png"}}]);