"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[40100],{59380:function(e,n,t){t.r(n),t.d(n,{assets:function(){return m},contentTitle:function(){return u},default:function(){return v},frontMatter:function(){return c},metadata:function(){return p},toc:function(){return y}});var i=t(83117),r=t(80102),o=(t(67294),t(3905)),a=t(76018),l=t(71871),s=t(74606),d=["components"],c={title:"Merkle Key Collection",sidebar_label:"Merkle Key Collection",description:"Explain why, how to use and how merkle key collections work",image:"/img/Identity_icon.png",keywords:["Merkle Key Collections","DID"]},u=void 0,p={unversionedId:"verifiable_credentials/merkle_key_collection",id:"verifiable_credentials/merkle_key_collection",title:"Merkle Key Collection",description:"Explain why, how to use and how merkle key collections work",source:"@site/external/identity.rs/documentation/docs/verifiable_credentials/merkle_key_collection.mdx",sourceDirName:"verifiable_credentials",slug:"/verifiable_credentials/merkle_key_collection",permalink:"/identity.rs/verifiable_credentials/merkle_key_collection",editUrl:"https://github.com/iotaledger/identity.rs/edit/dev/external/identity.rs/documentation/docs/verifiable_credentials/merkle_key_collection.mdx",tags:[],version:"current",frontMatter:{title:"Merkle Key Collection",sidebar_label:"Merkle Key Collection",description:"Explain why, how to use and how merkle key collections work",image:"/img/Identity_icon.png",keywords:["Merkle Key Collections","DID"]},sidebar:"docs",previous:{title:"Revocation",permalink:"/identity.rs/verifiable_credentials/revoke"},next:{title:"Verifiable Presentations",permalink:"/identity.rs/verifiable_credentials/verifiable_presentations"}},m={},y=[{value:"Example",id:"example",level:2}],k={toc:y};function v(e){var n=e.components,t=(0,r.Z)(e,d);return(0,o.kt)("wrapper",(0,i.Z)({},k,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"TODO: Explain why, how to use and how merkle key collections work."),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("p",null,"This example shows how you can sign/revoke verifiable credentials on scale.\nInstead of ",(0,o.kt)("a",{parentName:"p",href:"revoke"},"revoking the entire verification method"),", you can revoke a single key from a MerkleKeyCollection.\nYou can create this MerkleKeyCollection as a collection of a power of 2 amount of keys.\nThe issuer should use every key once to sign a verifiable credential."),(0,o.kt)(a.Z,{groupId:"programming-languages",defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Node.js",value:"nodejs"}],mdxType:"Tabs"},(0,o.kt)(l.Z,{value:"rust",mdxType:"TabItem"},(0,o.kt)(s.Z,{className:"language-rust",mdxType:"CodeBlock"},'// Copyright 2020-2022 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! An example that revokes a key and shows how verification fails as a consequence.\n//!\n//! cargo run --example merkle_key\n\nuse identity::core::Timestamp;\nuse identity::credential::Credential;\nuse identity::crypto::merkle_key::Sha256;\nuse identity::crypto::merkle_tree::Proof;\nuse identity::crypto::KeyCollection;\nuse identity::crypto::PrivateKey;\nuse identity::crypto::PublicKey;\nuse identity::did::MethodScope;\nuse identity::iota::CredentialValidationOptions;\nuse identity::iota::CredentialValidator;\nuse identity::iota::Receipt;\nuse identity::iota::Resolver;\nuse identity::iota_core::IotaDID;\nuse identity::iota_core::IotaVerificationMethod;\nuse identity::prelude::*;\nuse rand::rngs::OsRng;\nuse rand::Rng;\n\nmod common;\nmod create_did;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n  // Create a client instance to send messages to the Tangle.\n  let client: Client = Client::new().await?;\n\n  // Create a signed DID Document/KeyPair for the credential issuer (see create_did.rs).\n  let (mut issuer_doc, issuer_key, issuer_receipt): (IotaDocument, KeyPair, Receipt) = create_did::run().await?;\n\n  // Create a signed DID Document/KeyPair for the credential subject (see create_did.rs).\n  let (subject_doc, _, _): (IotaDocument, KeyPair, Receipt) = create_did::run().await?;\n\n  // Generate a Merkle Key Collection Verification Method with 8 keys (Must be a power of 2)\n  let keys: KeyCollection = KeyCollection::new_ed25519(8)?;\n  let method_did: IotaDID = issuer_doc.id().clone();\n  let method = IotaVerificationMethod::new_merkle_key::<Sha256>(method_did, &keys, "merkle-key")?;\n\n  // Add to the DID Document as a general-purpose verification method\n  issuer_doc.insert_method(method, MethodScope::VerificationMethod)?;\n  issuer_doc.metadata.previous_message_id = *issuer_receipt.message_id();\n  issuer_doc.metadata.updated = Timestamp::now_utc();\n  issuer_doc.sign_self(issuer_key.private(), issuer_doc.default_signing_method()?.id().clone())?;\n\n  // Publish the Identity to the IOTA Network and log the results.\n  // This may take a few seconds to complete proof-of-work.\n  let receipt: Receipt = client.publish_document(&issuer_doc).await?;\n  println!("Publish Receipt > {:#?}", receipt);\n\n  // Create an unsigned Credential with claims about `subject` specified by `issuer`.\n  let mut credential: Credential = common::issue_degree(&issuer_doc, &subject_doc)?;\n\n  // Select a random key from the collection\n  let index: usize = OsRng.gen_range(0..keys.len());\n\n  let public: &PublicKey = keys.public(index).unwrap();\n  let private: &PrivateKey = keys.private(index).unwrap();\n\n  // Generate an inclusion proof for the selected key\n  let proof: Proof<Sha256> = keys.merkle_proof(index).unwrap();\n\n  // Sign the Credential with the issuers private key\n  issuer_doc\n    .signer(private)\n    .method("merkle-key")\n    .merkle_key((public, &proof))\n    .sign(&mut credential)?;\n\n  println!("Credential JSON > {:#}", credential);\n\n  // Check the verifiable credential is valid\n  let resolver: Resolver = Resolver::new().await?;\n  let resolved_issuer_doc = resolver.resolve_credential_issuer(&credential).await?;\n  CredentialValidator::validate(\n    &credential,\n    &resolved_issuer_doc,\n    &CredentialValidationOptions::default(),\n    identity::iota::FailFast::FirstError,\n  )?;\n\n  println!("Credential successfully validated!");\n\n  // The Issuer would like to revoke the credential (and therefore revokes key at `index`)\n  issuer_doc\n    .try_resolve_method_mut("merkle-key")?\n    .revoke_merkle_key(index as u32)?;\n  issuer_doc.metadata.previous_message_id = *receipt.message_id();\n  issuer_doc.metadata.updated = Timestamp::now_utc();\n  issuer_doc.sign_self(issuer_key.private(), issuer_doc.default_signing_method()?.id().clone())?;\n\n  let receipt: Receipt = client.publish_document(&issuer_doc).await?;\n\n  println!("Publish Receipt > {:#?}", receipt);\n\n  // Check that verifiable credential is revoked\n\n  let resolved_issuer_doc = resolver.resolve_credential_issuer(&credential).await?;\n  let result: Result<()> = CredentialValidator::validate(\n    &credential,\n    &resolved_issuer_doc,\n    &CredentialValidationOptions::default(),\n    identity::iota::FailFast::FirstError,\n  )\n  .map_err(Into::into);\n\n  assert!(result.is_err());\n\n  println!("Credential successfully revoked!");\n\n  Ok(())\n}\n')),(0,o.kt)(l.Z,{value:"nodejs",mdxType:"TabItem"},(0,o.kt)(s.Z,{className:"language-javascript",mdxType:"CodeBlock"},'// Copyright 2020-2022 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport {\n    Client,\n    Credential,\n    CredentialValidationOptions,\n    CredentialValidator,\n    Digest,\n    FailFast,\n    KeyCollection,\n    KeyType,\n    MethodScope,\n    Resolver,\n    SignatureOptions,\n    Timestamp,\n    VerificationMethod\n} from \'@iota/identity-wasm\';\nimport {createIdentity} from \'./create_did\';\n\n/**\n This example shows how to sign/revoke verifiable credentials on scale.\n Instead of revoking the entire verification method, a single key can be revoked from a MerkleKeyCollection.\n This MerkleKeyCollection can be created as a collection of a power of 2 amount of keys.\n Every key should be used once by the issuer for signing a verifiable credential.\n When the verifiable credential must be revoked, the issuer revokes the index of the revoked key.\n\n @param {{network: Network, explorer: ExplorerUrl}} clientConfig\n **/\nasync function merkleKey(clientConfig) {\n    // Create a client instance to publish messages to the configured Tangle network.\n    const client = await Client.fromConfig({\n        network: clientConfig.network\n    });\n\n    // Creates new identities (See "create_did" example)\n    const alice = await createIdentity(clientConfig);\n    const issuer = await createIdentity(clientConfig);\n\n    // Add a Merkle Key Collection Verification Method with 8 keys (Must be a power of 2)\n    const keys = new KeyCollection(KeyType.Ed25519, 8);\n    const method = VerificationMethod.newMerkleKey(Digest.Sha256, issuer.doc.id, keys, "key-collection")\n\n    // Add to the DID Document as a general-purpose verification method\n    issuer.doc.insertMethod(method, MethodScope.VerificationMethod());\n    issuer.doc.metadataPreviousMessageId = issuer.receipt.messageId;\n    issuer.doc.metadataUpdated = Timestamp.nowUTC();\n    issuer.doc.signSelf(issuer.key, issuer.doc.defaultSigningMethod().id);\n\n    // Publish the Identity to the IOTA Network and log the results.\n    // This may take a few seconds to complete proof-of-work.\n    const receipt = await client.publishDocument(issuer.doc);\n    console.log(`Identity Update: ${clientConfig.explorer.messageUrl(receipt.messageId)}`);\n\n    // Prepare a credential subject indicating the degree earned by Alice\n    let credentialSubject = {\n        id: alice.doc.id.toString(),\n        name: "Alice",\n        degreeName: "Bachelor of Science and Arts",\n        degreeType: "BachelorDegree",\n        GPA: "4.0"\n    };\n\n    // Create an unsigned `UniversityDegree` credential for Alice\n    const unsignedVc = Credential.extend({\n        id: "https://example.edu/credentials/3732",\n        type: "UniversityDegreeCredential",\n        issuer: issuer.doc.id.toString(),\n        credentialSubject,\n    });\n\n    // Sign the credential with Issuer\'s Merkle Key Collection method, with key index 0\n    const signedVc = issuer.doc.signCredential(unsignedVc, {\n        method: method.id.toString(),\n        public: keys.public(0),\n        private: keys.private(0),\n        proof: keys.merkleProof(Digest.Sha256, 0)\n    }, SignatureOptions.default());\n\n    // Check the verifiable credential is valid\n    const resolver = await Resolver\n        .builder()\n        .client(client)\n        .build();\n    const resolvedIssuerDoc = await resolver.resolveCredentialIssuer(signedVc);\n    CredentialValidator.validate(\n        signedVc,\n        resolvedIssuerDoc,\n        CredentialValidationOptions.default(),\n        FailFast.FirstError\n    );\n    console.log(`Credential successfully validated!"`);\n\n    // The Issuer would like to revoke the credential (and therefore revokes key 0).\n    issuer.doc.revokeMerkleKey(method.id.toString(), 0);\n    issuer.doc.metadataPreviousMessageId = receipt.messageId;\n    issuer.doc.metadataUpdated = Timestamp.nowUTC();\n    issuer.doc.signSelf(issuer.key, issuer.doc.defaultSigningMethod().id);\n    const nextReceipt = await client.publishDocument(issuer.doc);\n    console.log(`Identity Update: ${clientConfig.explorer.messageUrl(nextReceipt.messageId)}`);\n\n    // Check the verifiable credential is revoked\n    let vc_revoked = false;\n    try {\n        // Resolve the issuer\'s updated DID Document to ensure the key was revoked successfully.\n        const updatedResolvedIssuerDoc = await resolver.resolveCredentialIssuer(signedVc);\n        CredentialValidator.validate(\n            signedVc,\n            updatedResolvedIssuerDoc,\n            CredentialValidationOptions.default(),\n            FailFast.FirstError\n        );\n    } catch (exception) {\n        console.log(`${exception.message}`)\n        vc_revoked = true;\n    }\n\n    if (!vc_revoked) throw new Error("VC not revoked");\n    console.log(`Credential successfully revoked!`);\n}\n\nexport {merkleKey};\n'))))}v.isMDXComponent=!0},71871:function(e,n,t){t.d(n,{Z:function(){return r}});var i=t(67294);function r(e){var n=e.children,t=e.hidden,r=e.className;return i.createElement("div",{role:"tabpanel",hidden:t,className:r},n)}},76018:function(e,n,t){t.d(n,{Z:function(){return c}});var i=t(83117),r=t(67294),o=t(5730),a=t(10109),l=t(86010),s="tabItem_LplD";function d(e){var n,t,o,d=e.lazy,c=e.block,u=e.defaultValue,p=e.values,m=e.groupId,y=e.className,k=r.Children.map(e.children,(function(e){if((0,r.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),v=null!=p?p:k.map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes}})),h=(0,a.lx)(v,(function(e,n){return e.value===n.value}));if(h.length>0)throw new Error('Docusaurus error: Duplicate values "'+h.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var f=null===u?u:null!=(n=null!=u?u:null==(t=k.find((function(e){return e.props.default})))?void 0:t.props.value)?n:null==(o=k[0])?void 0:o.props.value;if(null!==f&&!v.some((function(e){return e.value===f})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+f+'" but none of its children has the corresponding value. Available values are: '+v.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var g=(0,a.UB)(),_=g.tabGroupChoices,b=g.setTabGroupChoices,w=(0,r.useState)(f),C=w[0],I=w[1],x=[],D=(0,a.o5)().blockElementScrollPositionUntilNextRender;if(null!=m){var T=_[m];null!=T&&T!==C&&v.some((function(e){return e.value===T}))&&I(T)}var M=function(e){var n=e.currentTarget,t=x.indexOf(n),i=v[t].value;i!==C&&(D(n),I(i),null!=m&&b(m,i))},K=function(e){var n,t=null;switch(e.key){case"ArrowRight":var i=x.indexOf(e.currentTarget)+1;t=x[i]||x[0];break;case"ArrowLeft":var r=x.indexOf(e.currentTarget)-1;t=x[r]||x[x.length-1]}null==(n=t)||n.focus()};return r.createElement("div",{className:"tabs-container"},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":c},y)},v.map((function(e){var n=e.value,t=e.label,o=e.attributes;return r.createElement("li",(0,i.Z)({role:"tab",tabIndex:C===n?0:-1,"aria-selected":C===n,key:n,ref:function(e){return x.push(e)},onKeyDown:K,onFocus:M,onClick:M},o,{className:(0,l.Z)("tabs__item",s,null==o?void 0:o.className,{"tabs__item--active":C===n})}),null!=t?t:n)}))),d?(0,r.cloneElement)(k.filter((function(e){return e.props.value===C}))[0],{className:"margin-vert--md"}):r.createElement("div",{className:"margin-vert--md"},k.map((function(e,n){return(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==C})}))))}function c(e){var n=(0,o.Z)();return r.createElement(d,(0,i.Z)({key:String(n)},e))}}}]);