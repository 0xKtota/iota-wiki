"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[35777],{54645:function(e,n,t){t.r(n),t.d(n,{assets:function(){return M},contentTitle:function(){return I},default:function(){return R},frontMatter:function(){return A},metadata:function(){return O},toc:function(){return D}});var a=t(87462),s=t(63366),i=(t(67294),t(3905)),r=t(36232),o=t(84661),d=["components"],l={toc:[]};function p(e){var n=e.components,t=(0,s.Z)(e,d);return(0,i.kt)("wrapper",(0,a.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"Example Seed")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"The examples use an example seed ",(0,i.kt)("inlineCode",{parentName:"p"},"b3d7092195c36d47133ff786d4b0a1ef2ee6a0052f6e87b6dc337935c70c531e")," that is stored in an\nenvironment variable called ",(0,i.kt)("inlineCode",{parentName:"p"},"IOTA_SEED_SECRET"),". This seed serves for training purposes only."))))}p.isMDXComponent=!0;var u=t(87308),c=t(94365),m=["components"],h=c.Z.indexOf("public static void generateAddresses() {"),g=c.Z.indexOf("public static void getBalance() {"),f=c.Z.substring(h,g),k={toc:[]};function v(e){var n=e.components,t=(0,s.Z)(e,m);return(0,i.kt)("wrapper",(0,a.Z)({},k,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"You can generate an IOTA address using the\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/java/api_reference#getaddressesbuilder"},(0,i.kt)("inlineCode",{parentName:"a"},"GetAddressesBuilder"))," helper class and calling the    ",(0,i.kt)("inlineCode",{parentName:"p"},"GetAddressesBuilder::from(seed: &str)")," function\nand respective chaining calls that will return a list of tuples with the generated addresses. You can find more information\non the parameters in the ",(0,i.kt)("a",{parentName:"p",href:"/iota.rs/explanations/address_key_space"},"Address/Key Space section"),"."),(0,i.kt)("p",null,"The whole process is deterministic. This means the output is the same as long as the seed is the same:"),(0,i.kt)(u.Z,{className:"language-java",mdxType:"CodeBlock"},f),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Output example"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-string"},"[\n  'atoi1qz6dr6dtl0856tf0pczz7gesrf7j8a4vr00q58ld2zx7ttlv3p96snpym9z',\n  'atoi1qpp7sz28a0ghvd6knwnljr7j2s04qquduuc5vlz94fwf94zznj2yv5ew2c4',\n  'atoi1qzje6zhg5vu456eg3z84ekcfn3laxqyczche5eeqhcdh3w9yr5sqvr4z4td',\n  'atoi1qqwhxjmcvmatpedeedapgx0vwyupfwx9k5n4w0lnc5l6vmz78aavwhs55v0',\n  'atoi1qzg63t9880jtfysvpq7rrynz0rqt3kd2fw8r4934ezraz9dpwvzxkw2dtmh'\n]\n")),(0,i.kt)("p",null,"IOTA addresses are represented by a checksumed base-32 string (Bech32). You can find a detailed explanation in the\n",(0,i.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/guides/developer/#iota-15-address-anatom"},"Chrysalis documentations"),", but here are\nparts relevant to this example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If an address starts with ",(0,i.kt)("inlineCode",{parentName:"li"},"atoi")," then it means it is related to ",(0,i.kt)("inlineCode",{parentName:"li"},"devnet"),". ",(0,i.kt)("inlineCode",{parentName:"li"},"iota")," stands for ",(0,i.kt)("inlineCode",{parentName:"li"},"mainnet"),"."),(0,i.kt)("li",{parentName:"ul"},"Number ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," at the 5",(0,i.kt)("sup",null,"th")," position is just a separator."),(0,i.kt)("li",{parentName:"ul"},"The last 6 characters are reserved for a checksum.")),(0,i.kt)("p",null,"Addresses can be also represented in a hex format using the\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/java/api_reference#bech32tohexbech32-string"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.bech32ToHex(bech32)"))," function."),(0,i.kt)("p",null,"If you want to quickly validate any IOTA address, you can use the\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/java/api_reference#isaddressvalidaddress-boolean"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.isAddressValid()"))," function that returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," value. You should\nperform a sanity check on address before using it."))}v.isMDXComponent=!0;var y=["components"],x={toc:[]};function w(e){var n=e.components,t=(0,s.Z)(e,y);return(0,i.kt)("wrapper",(0,a.Z)({},x,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"You can generate an IOTA address using the ",(0,i.kt)("a",{parentName:"p",href:"../libraries/nodejs/api_reference#addressgetter"},(0,i.kt)("inlineCode",{parentName:"a"},"AddressGetter"))," helper\nclass and calling the ",(0,i.kt)("a",{parentName:"p",href:"../libraries/nodejs/api_reference#getaddressesseed-addressgetter"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.getAddresses()")),"\nfunction and respective chaining calls that will return a list of tuples with the generated addresses. You can find\nmore information on the parameters in the ",(0,i.kt)("a",{parentName:"p",href:"/iota.rs/explanations/address_key_space"},"Address/Key Space section"),"."),(0,i.kt)("p",null,"The whole process is deterministic. This means the output is the same as long as the seed is the same:"),(0,i.kt)(u.Z,{className:"language-javascript",mdxType:"CodeBlock"},"async function run() {\n  const { ClientBuilder } = require('@iota/client');\n\n  // Get the seed from environment variable\n  const IOTA_SEED_SECRET = process.env.IOTA_SEED_SECRET;\n\n  // client will connect to testnet by default\n  const client = new ClientBuilder().build();\n\n  const addresses = await client.getAddresses(IOTA_SEED_SECRET)\n    .accountIndex(0)\n    .range(0, 5)\n    .get();\n\n  console.log(addresses);\n}\n\nrun()\n"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Output example"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-string"},"[\n  'atoi1qz6dr6dtl0856tf0pczz7gesrf7j8a4vr00q58ld2zx7ttlv3p96snpym9z',\n  'atoi1qpp7sz28a0ghvd6knwnljr7j2s04qquduuc5vlz94fwf94zznj2yv5ew2c4',\n  'atoi1qzje6zhg5vu456eg3z84ekcfn3laxqyczche5eeqhcdh3w9yr5sqvr4z4td',\n  'atoi1qqwhxjmcvmatpedeedapgx0vwyupfwx9k5n4w0lnc5l6vmz78aavwhs55v0',\n  'atoi1qzg63t9880jtfysvpq7rrynz0rqt3kd2fw8r4934ezraz9dpwvzxkw2dtmh'\n]\n")),(0,i.kt)("p",null,"IOTA addresses are represented by a checksumed base-32 string (Bech32). You can find a detailed explanation in the\n",(0,i.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/guides/developer/#iota-15-address-anatom"},"Chrysalis documentations"),", but here are\nparts relevant to this example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If an address starts with ",(0,i.kt)("inlineCode",{parentName:"li"},"atoi")," then it means it is related to ",(0,i.kt)("inlineCode",{parentName:"li"},"devnet"),". ",(0,i.kt)("inlineCode",{parentName:"li"},"iota")," stands for ",(0,i.kt)("inlineCode",{parentName:"li"},"mainnet"),"."),(0,i.kt)("li",{parentName:"ul"},"Number ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," at the 5",(0,i.kt)("sup",null,"th")," positvion is just a separator."),(0,i.kt)("li",{parentName:"ul"},"The last 6 characters are reserved for a checksum.")),(0,i.kt)("p",null,"Addresses can be also represented in a hex format and ",(0,i.kt)("inlineCode",{parentName:"p"},"iota.rs")," provides some convenient functions to convert addresses:\n",(0,i.kt)("a",{parentName:"p",href:"../libraries/nodejs/api_reference#bech32tohexbech32"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.bech32ToHex(bech32)"))," and\n",(0,i.kt)("a",{parentName:"p",href:"../libraries/nodejs/api_reference#hextobech32hex-bech32_hrp-optional"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.hexToBech32(hex, bech32_hrp (optional))")),"."),(0,i.kt)("p",null,"If you want to quickly validate any IOTA address, you can use the\n",(0,i.kt)("a",{parentName:"p",href:"../libraries/nodejs/api_reference#isaddressvalidaddress-string-boolean"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.isAddressValid()"))," function that\nreturns a ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," value. You should perform a sanity check on address before using it."))}w.isMDXComponent=!0;var _=["components"],b={toc:[]};function N(e){var n=e.components,t=(0,s.Z)(e,_);return(0,i.kt)("wrapper",(0,a.Z)({},b,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"You can generate an IOTA address using the\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/python/api_reference##get_addressesseed-account_index-optional-input_range_begin-optional-input_range_end-optional-get_all-optional-liststr-bool-optional"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.get_addresses()")),"\nfunction that will return a list of tuples with the generated addresses. You can find more information on the\nparameters in the ",(0,i.kt)("a",{parentName:"p",href:"/iota.rs/explanations/address_key_space"},"Address/Key Space section"),"."),(0,i.kt)("p",null,"The whole process is deterministic. This means the output is the same as long as the seed is the same:"),(0,i.kt)(u.Z,{className:"language-python",mdxType:"CodeBlock"},"import os\nimport iota_client\n\n# Get the seed from environment variable\nIOTA_SEED_SECRET = os.getenv('IOTA_SEED_SECRET')\nif not IOTA_SEED_SECRET:\n    raise Exception(\"Please define environment variable called `IOTA_SEED_SECRET`\")\n\nclient = iota_client.Client()\n\naddress_changed_list = client.get_addresses(\n    seed=IOTA_SEED_SECRET,\n    account_index=0,\n    input_range_begin=0,\n    input_range_end=10,\n    get_all=True\n)\nprint(address_changed_list)"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Output example"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-string"},"[('atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86', False),\n ('atoi1qzfvkkp398v7hhvu89fu88hxctf7snwc9sf3a3nd7msfv77jk7qk2ah07s3', True),\n ('atoi1qq4t98j5y8wxkaujue99mjwqcp6jvvmsd5lv0755sz7dtjdz3p2lydv76sy', False),\n ('atoi1qrhzhjxc4z8vpwjt3hafs5xpdng5katqe890p0h95mc0l273j8yzxn7r4hc', True),\n ('atoi1qputu0yvfvxd7g39wf4rc67e0f0dyhl6enxu9jxnsrjqmemh067tw7qelyc', False),\n ('atoi1qptg5w2x47qwjf3gpqt3h7d2ey5x7xf8v7qtt29gkxt4mjfjfc28sutvd8a', True),\n ('atoi1qprvelq9paakh72fgm6j2kf8kexadw3t5xljer9dpsep5c7wx5mjwdxch6z', False),\n ('atoi1qrwk37tz47ddng9kpxfflkpz5tplcq7ll56v4acam04307xk70l7uf6wg8j', True),\n ('atoi1qper3zr5xe9x0wqs35ytwh622870g44frkyygdhs0ds8yejle3xujhq7dx3', False),\n ('atoi1qq6lkr9hucfylqjaqphu0stvk8pcmsx98r7ukuq40asszwmqytlnc058thk', True),\n ('atoi1qzpn7se3ryhscmqg404pycxzvfpt8v4xn8aul0tqdh00xsncgnxu7na7zjj', False),\n ('atoi1qz4qqakty9qytw8fk9shelt9lwlvv83s5ggt3wjag9fkgcc74z78w4l86y5', True),\n ('atoi1qp20uddchglqry0l5qnjg5aln8d5rk2v5l45hwrxv9z0daxs7u6xcsh4077', False),\n ('atoi1qrlqm2u5txxxnjx22fxq0jfjzk6l4nwnue6ht5pepk65m2f4xmxqynmxu2m', True),\n ('atoi1qqydc70mpjdvl8l2wyseaseqwzhmedzzxrn4l9g2c8wdcsmhldz0ulwjxpz', False),\n ('atoi1qrkjennxyl2xcqem6x69ya65sasma33z0ux872k846lqft0s3qf7k6lqpft', True),\n ('atoi1qr4yuekp30ff7mnnnjwy9tdhynxmlmkpuxf70qurtwudp2zpf3jeyw4uh37', False),\n ('atoi1qp6m5sz5ayjtccfxapdk5lp4qkheyfg0emzntmulyxzftps730vcul8dmqr', True),\n ('atoi1qzrwhkzhu67fqltfffwljejawdcghedukpgu9x6tzevwlnq89gmfjtayhgz', False),\n ('atoi1qpehxcp24z947dgupjqc9ktkn5ylmdxqqnx83m7xlajnf8005756u4n7z77', True)]\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Each tuple contains ",(0,i.kt)("inlineCode",{parentName:"li"},"address")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"bool")," value indicating if the address is a ",(0,i.kt)("inlineCode",{parentName:"li"},"change")," address or not. ",(0,i.kt)("inlineCode",{parentName:"li"},"True"),"\nmeans the address is a change address (internal). There are two independent sets of addresses (10 items per each)."),(0,i.kt)("li",{parentName:"ul"},"This behavior is controlled by the ",(0,i.kt)("inlineCode",{parentName:"li"},"get_all")," argument. ",(0,i.kt)("inlineCode",{parentName:"li"},"get_all=False")," (default) generates only public addresses.")),(0,i.kt)("p",null,"IOTA addresses are represented by a checksumed base-32 string (Bech32). You can find a detailed explanation in the\n",(0,i.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/guides/developer/#iota-15-address-anatom"},"Chrysalis documentations"),", but here are\nparts relevant to this example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If an address starts with ",(0,i.kt)("inlineCode",{parentName:"li"},"atoi")," then it means it is related to ",(0,i.kt)("inlineCode",{parentName:"li"},"devnet"),". ",(0,i.kt)("inlineCode",{parentName:"li"},"iota")," stands for ",(0,i.kt)("inlineCode",{parentName:"li"},"mainnet"),"."),(0,i.kt)("li",{parentName:"ul"},"Number ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," at the 5",(0,i.kt)("sup",null,"th")," position is just a separator."),(0,i.kt)("li",{parentName:"ul"},"The last 6 characters are reserved for a checksum.")),(0,i.kt)("p",null,"Addresses can be also represented in a hex format and ",(0,i.kt)("inlineCode",{parentName:"p"},"iota.rs")," provides some convenient functions to convert addresses:\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/python/api_reference#bech32_to_hexbech32"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.bech32_to_hex()"))," and\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/python/api_reference#hex_to_bech32hex-bech32_hrp-optional"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.hex_to_bech32()")),"."),(0,i.kt)("p",null,"If you want to quickly validate any IOTA address, you can use the\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/python/api_reference#is_address_validaddress-bool"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.is_address_valid()"))," function that returns a\n",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," value. You should perform a sanity check on address before using it."))}N.isMDXComponent=!0;var C=["components"],E={toc:[]};function T(e){var n=e.components,t=(0,s.Z)(e,C);return(0,i.kt)("wrapper",(0,a.Z)({},E,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"You can generate IOTA addresses calling the\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/iota-client/latest/iota_client/client/struct.Client.html#method.get_addresses"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.get_addresses()")),"\nfunction and respective chaining calls that will return a list of tuples with the generated addresses. You can find\nmore information on the parameters in the ",(0,i.kt)("a",{parentName:"p",href:"/iota.rs/explanations/address_key_space"},"Address/Key Space section"),"."),(0,i.kt)("p",null,"The whole process is deterministic. This means the output is the same as long as the seed is the same:"),(0,i.kt)(u.Z,{className:"language-javascript",mdxType:"CodeBlock"},'// Copyright 2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! cargo run --example 03_generate_addresses --release\n\nuse iota_client::{api::GetAddressesBuilder, Client, Seed};\nextern crate dotenv;\nuse dotenv::dotenv;\nuse std::env;\n\n/// In this example we will create addresses from a seed defined in .env\n\n#[tokio::main]\nasync fn main() {\n    // Create a client instance\n    let iota = Client::builder()\n        .with_node("https://api.lb-0.h.chrysalis-devnet.iota.cafe") // Insert your node URL here\n        .unwrap()\n        .finish()\n        .await\n        .unwrap();\n\n    // This example uses dotenv, which is not safe for use in production\n    dotenv().ok();\n\n    let seed = Seed::from_bytes(&hex::decode(env::var("NONSECURE_USE_OF_DEVELOPMENT_SEED_1").unwrap()).unwrap());\n\n    // Generate addresses with default account index and range\n    let addresses = iota.get_addresses(&seed).finish().await.unwrap();\n    println!("List of generated public addresses:\\n{:?}\\n", addresses);\n\n    // Generate addresses with custom account index and range\n    let addresses = iota\n        .get_addresses(&seed)\n        .with_account_index(0)\n        .with_range(0..4)\n        .finish()\n        .await\n        .unwrap();\n\n    println!("List of generated public addresses:\\n{:?}\\n", addresses);\n\n    // Generate public (false) & internal (true) addresses\n    let addresses = iota.get_addresses(&seed).with_range(0..4).get_all().await.unwrap();\n    println!("List of generated public and internal addresses:\\n{:?}\\n", addresses);\n\n    // Generate public addresses offline with the bech32_hrp defined\n    let addresses = GetAddressesBuilder::new(&seed)\n        .with_bech32_hrp("atoi".into())\n        .with_account_index(0)\n        .with_range(0..4)\n        .finish()\n        .await\n        .unwrap();\n\n    println!("List of offline generated public addresses:\\n{:?}\\n", addresses);\n}\n'),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Output example"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-palintext"},'List of generated public addresses:\n[\n"atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r",\n"atoi1qpnrumvaex24dy0duulp4q07lpa00w20ze6jfd0xly422kdcjxzakzsz5kf",\n"atoi1qz4sfmp605vnj6fxt0sf0cwclffw5hpxjqkf6fthyd74r9nmmu337m3lwl2",\n...]\n\nList of generated public addresses:\n[\n"atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r",\n"atoi1qpnrumvaex24dy0duulp4q07lpa00w20ze6jfd0xly422kdcjxzakzsz5kf",\n"atoi1qz4sfmp605vnj6fxt0sf0cwclffw5hpxjqkf6fthyd74r9nmmu337m3lwl2",\n...]\n\nList of generated public and internal addresses:\n[\n("atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r", false),\n("atoi1qprxpfvaz2peggq6f8k9cj8zfsxuw69e4nszjyv5kuf8yt70t2847shpjak", true),\n("atoi1qpnrumvaex24dy0duulp4q07lpa00w20ze6jfd0xly422kdcjxzakzsz5kf", false),\n...]\n\nList of offline generated public addresses:\n["atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r",\n"atoi1qpnrumvaex24dy0duulp4q07lpa00w20ze6jfd0xly422kdcjxzakzsz5kf",\n"atoi1qz4sfmp605vnj6fxt0sf0cwclffw5hpxjqkf6fthyd74r9nmmu337m3lwl2",\n...]\n\n\n')),(0,i.kt)("p",null,"IOTA addresses are represented by a checksumed base-32 string (Bech32). You can find a detailed explanation in the\n",(0,i.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/guides/developer/#iota-15-address-anatom"},"Chrysalis documentations"),", but here are\nparts relevant to this example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If an address starts with ",(0,i.kt)("inlineCode",{parentName:"li"},"atoi")," then it means it is related to ",(0,i.kt)("inlineCode",{parentName:"li"},"devnet"),". ",(0,i.kt)("inlineCode",{parentName:"li"},"iota")," stands for ",(0,i.kt)("inlineCode",{parentName:"li"},"mainnet"),"."),(0,i.kt)("li",{parentName:"ul"},"Number ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," at the 5",(0,i.kt)("sup",null,"th")," position is just a separator."),(0,i.kt)("li",{parentName:"ul"},"The last 6 characters are reserved for a checksum.")),(0,i.kt)("p",null,"Addresses can be also represented in a hex format and ",(0,i.kt)("inlineCode",{parentName:"p"},"iota.rs")," provides some convenient functions to convert addresses:\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/iota-client/latest/iota_client/client/struct.Client.html#method.bech32_to_hex"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.bech32ToHex(bech32)")),"\nand ",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/iota-client/latest/iota_client/client/struct.Client.html#method.hex_to_bech32"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.hex_to_bech32(hex, bech32_hrp (optional))")),"."),(0,i.kt)("p",null,"If you want to quickly validate any IOTA address, you can use the\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/iota-client/latest/iota_client/client/struct.Client.html#method.is_address_valid"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.is_address_valid()")),"\nfunction that returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," value. You should perform a sanity check on address before using it."))}T.isMDXComponent=!0;var q=["components"],S={toc:[]};function z(e){var n=e.components,t=(0,s.Z)(e,q);return(0,i.kt)("wrapper",(0,a.Z)({},S,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"You can generate an IOTA address using the ",(0,i.kt)("a",{parentName:"p",href:"./../libraries/wasm/api_reference#addressgetter"},(0,i.kt)("inlineCode",{parentName:"a"},"AddressGetter"))," helper\nclass and calling the ",(0,i.kt)("a",{parentName:"p",href:"./../libraries/wasm/api_reference#getaddressesseed-addressgetter"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.getAddresses()")),"\nfunction and respective chaining calls that will return a list of tuples with the generated addresses. You can find\nmore information on the parameters in the ",(0,i.kt)("a",{parentName:"p",href:"/iota.rs/explanations/address_key_space"},"Address/Key Space section"),"."),(0,i.kt)("p",null,"The whole process is deterministic. This means the output is the same as long as the seed is the same:"),(0,i.kt)(u.Z,{className:"language-javascript",mdxType:"CodeBlock"},"async function run() {\n  const { ClientBuilder } = require('../node')\n\n  // Get the seed from environment variable\n  const IOTA_SEED_SECRET = process.env.IOTA_SEED_SECRET;\n\n  // client will connect to testnet by default\n  const client = await new ClientBuilder().build();\n\n  const addresses = await client.getAddresses(IOTA_SEED_SECRET)\n    .accountIndex(0)\n    .range(0, 5)\n    .get();\n\n  console.log(addresses);\n}\n\nrun()\n"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Output example"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-string"},"[\n  'atoi1qz6dr6dtl0856tf0pczz7gesrf7j8a4vr00q58ld2zx7ttlv3p96snpym9z',\n  'atoi1qpp7sz28a0ghvd6knwnljr7j2s04qquduuc5vlz94fwf94zznj2yv5ew2c4',\n  'atoi1qzje6zhg5vu456eg3z84ekcfn3laxqyczche5eeqhcdh3w9yr5sqvr4z4td',\n  'atoi1qqwhxjmcvmatpedeedapgx0vwyupfwx9k5n4w0lnc5l6vmz78aavwhs55v0',\n  'atoi1qzg63t9880jtfysvpq7rrynz0rqt3kd2fw8r4934ezraz9dpwvzxkw2dtmh'\n]\n")),(0,i.kt)("p",null,"IOTA addresses are represented by a checksumed base-32 string (Bech32). You can find a detailed explanation in the\n",(0,i.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/guides/developer/#iota-15-address-anatom"},"Chrysalis documentations"),", but here are\nparts relevant to this example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If an address starts with ",(0,i.kt)("inlineCode",{parentName:"li"},"atoi")," then it means it is related to ",(0,i.kt)("inlineCode",{parentName:"li"},"devnet"),". ",(0,i.kt)("inlineCode",{parentName:"li"},"iota")," stands for ",(0,i.kt)("inlineCode",{parentName:"li"},"mainnet"),"."),(0,i.kt)("li",{parentName:"ul"},"Number ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," at the 5",(0,i.kt)("sup",null,"th")," positvion is just a separator."),(0,i.kt)("li",{parentName:"ul"},"The last 6 characters are reserved for a checksum.")),(0,i.kt)("p",null,"Addresses can be also represented in a hex format and ",(0,i.kt)("inlineCode",{parentName:"p"},"iota.rs")," provides some convenient functions to convert addresses:\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/wasm/api_reference#clientbech32tohexaddress--string"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.bech32ToHex(address)"))," and\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/wasm/api_reference#clienthextobech32address-bech32--promiseany"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.hexToBech32(address, bech32) ")),"."),(0,i.kt)("p",null,"If you want to quickly validate any IOTA address, you can use the\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/wasm/api_reference#clientisaddressvalidaddress--boolean"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.isAddressValid()"))," function that\nreturns a ",(0,i.kt)("inlineCode",{parentName:"p"},"bool")," value. You should perform a sanity check on address before using it."))}z.isMDXComponent=!0;var j=["components"],A={title:"Generate Addresses",description:"You can generate an IOTA address using the Client.get_addresses() function that will return a list of tuples with the generated addresses.",image:"/img/logo/iota_mark_light.png",keywords:["how to","address","iota address","addressgetter","environment variable","java","nodejs","python","rust","wasm"]},I=void 0,O={unversionedId:"examples/generate_addresses",id:"examples/generate_addresses",title:"Generate Addresses",description:"You can generate an IOTA address using the Client.get_addresses() function that will return a list of tuples with the generated addresses.",source:"@site/content/build/iota.rs/production/documentation/docs/examples/generate_addresses.mdx",sourceDirName:"examples",slug:"/examples/generate_addresses",permalink:"/iota.rs/examples/generate_addresses",draft:!1,editUrl:"https://github.com/iotaledger/iota.rs/edit/production/documentation/content/build/iota.rs/production/documentation/docs/examples/generate_addresses.mdx",tags:[],version:"current",frontMatter:{title:"Generate Addresses",description:"You can generate an IOTA address using the Client.get_addresses() function that will return a list of tuples with the generated addresses.",image:"/img/logo/iota_mark_light.png",keywords:["how to","address","iota address","addressgetter","environment variable","java","nodejs","python","rust","wasm"]},sidebar:"docs",previous:{title:"Generate a Seed",permalink:"/iota.rs/examples/generate_seed"},next:{title:"Check a Balance",permalink:"/iota.rs/examples/get_balance"}},M={},D=[],L={toc:D};function R(e){var n=e.components,t=(0,s.Z)(e,j);return(0,i.kt)("wrapper",(0,a.Z)({},L,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)(p,{mdxType:"ExampleSeedNote"}),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(o.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(v,{mdxType:"JavaGenerateAddresses"})),(0,i.kt)(o.Z,{value:"nodejs",label:"Nodejs",mdxType:"TabItem"},(0,i.kt)(w,{mdxType:"NodejsGenerateAddresses"})),(0,i.kt)(o.Z,{value:"python",label:"Python",mdxType:"TabItem"},(0,i.kt)(N,{mdxType:"PythonGenerateAddresses"})),(0,i.kt)(o.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,i.kt)(T,{mdxType:"RustGenerateAddresses"})),(0,i.kt)(o.Z,{value:"wasm",label:"Wasm",mdxType:"TabItem"},(0,i.kt)(z,{mdxType:"WasmGenerateAddresses"}))))}R.isMDXComponent=!0},84661:function(e,n,t){t.d(n,{Z:function(){return r}});var a=t(67294),s=t(86010),i="tabItem_Ymn6";function r(e){var n=e.children,t=e.hidden,r=e.className;return a.createElement("div",{role:"tabpanel",className:(0,s.Z)(i,r),hidden:t},n)}},36232:function(e,n,t){t.d(n,{Z:function(){return m}});var a=t(87462),s=t(67294),i=t(86010),r=t(35074),o=t(74879),d=t(85425),l=t(51085),p="tabList__CuJ",u="tabItem_LNqP";function c(e){var n,t,r=e.lazy,c=e.block,m=e.defaultValue,h=e.values,g=e.groupId,f=e.className,k=s.Children.map(e.children,(function(e){if((0,s.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),v=null!=h?h:k.map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes}})),y=(0,o.l)(v,(function(e,n){return e.value===n.value}));if(y.length>0)throw new Error('Docusaurus error: Duplicate values "'+y.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var x=null===m?m:null!=(n=null!=m?m:null==(t=k.find((function(e){return e.props.default})))?void 0:t.props.value)?n:k[0].props.value;if(null!==x&&!v.some((function(e){return e.value===x})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+x+'" but none of its children has the corresponding value. Available values are: '+v.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var w=(0,d.U)(),_=w.tabGroupChoices,b=w.setTabGroupChoices,N=(0,s.useState)(x),C=N[0],E=N[1],T=[],q=(0,l.o5)().blockElementScrollPositionUntilNextRender;if(null!=g){var S=_[g];null!=S&&S!==C&&v.some((function(e){return e.value===S}))&&E(S)}var z=function(e){var n=e.currentTarget,t=T.indexOf(n),a=v[t].value;a!==C&&(q(n),E(a),null!=g&&b(g,String(a)))},j=function(e){var n,t=null;switch(e.key){case"ArrowRight":var a,s=T.indexOf(e.currentTarget)+1;t=null!=(a=T[s])?a:T[0];break;case"ArrowLeft":var i,r=T.indexOf(e.currentTarget)-1;t=null!=(i=T[r])?i:T[T.length-1]}null==(n=t)||n.focus()};return s.createElement("div",{className:(0,i.Z)("tabs-container",p)},s.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":c},f)},v.map((function(e){var n=e.value,t=e.label,r=e.attributes;return s.createElement("li",(0,a.Z)({role:"tab",tabIndex:C===n?0:-1,"aria-selected":C===n,key:n,ref:function(e){return T.push(e)},onKeyDown:j,onFocus:z,onClick:z},r,{className:(0,i.Z)("tabs__item",u,null==r?void 0:r.className,{"tabs__item--active":C===n})}),null!=t?t:n)}))),r?(0,s.cloneElement)(k.filter((function(e){return e.props.value===C}))[0],{className:"margin-top--md"}):s.createElement("div",{className:"margin-top--md"},k.map((function(e,n){return(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==C})}))))}function m(e){var n=(0,r.Z)();return s.createElement(c,(0,a.Z)({key:String(n)},e))}},94365:function(e,n){n.Z='package org.iota.client.example;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport org.iota.client.*;\nimport org.iota.client.local.*;\n\npublic class ExampleApp {\n\n    protected static final String MAINNET = "https://chrysalis-nodes.iota.cafe";\n\n    // Faucet: https://faucet.chrysalis-devnet.iota.cafe/\n    // Explorer: https://explorer.iota.org/devnet\n    protected static final String TESTNET = "https://api.lb-0.h.chrysalis-devnet.iota.cafe";\n    protected static final String TESTNET_LB = "api.lb-0.h.chrysalis-devnet.iota.cafe";\n\n    protected static final String NODE = TESTNET;\n\n    static {\n        NativeAPI.verifyLink();\n    }\n\n    public static void main(String[] args) {\n\n        try {\n            new ExampleApp();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public ExampleApp() {\n\n    }\n\n    private static Client node() {\n        Client iota = Client.Builder().withNode(NODE) // Insert your node URL here\n                // .withNodeAuth("https://somechrysalisiotanode.com", "jwt_or_null",\n                // "name_or_null", "password_or_null") //\n                // Optional authentication\n                .finish();\n        return iota;\n    }\n\n    public static void nodeInfo() {\n        try {\n            Client iota = node();\n\n            System.out.println("Node healthy: " + iota.getHealth());\n\n            NodeInfoWrapper info = iota.getInfo();\n            System.out.println("Node url: " + info.url());\n            System.out.println("Node Info: " + info.nodeInfo());\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void generateSeed() {\n        try {\n            SecretKey secret_key = SecretKey.generate();\n            System.out.println(RustHex.encode(secret_key.toBytes()));\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void generateAddresses() {\n        try {\n            Client iota = node();\n\n            String seed = RustHex.encode("NONSECURE_USE_OF_DEVELOPMENT_SEED_1");\n            String[] addresses = GetAddressesBuilder.from(seed).withClient(iota).withRange(0, 10).finish();\n            System.out.println(Arrays.toString(addresses));\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void getBalance() {\n        try {\n            Client iota = node();\n\n            String seed = "NONSECURE_USE_OF_DEVELOPMENT_SEED_1";\n\n            long seed_balance = iota.getBalance(seed).finish();\n            System.out.println("Account balance: " + seed_balance);\n\n            String address = "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r";\n\n            BalanceAddressResponse response = iota.getAddress().balance(address);\n            System.out.println("The balance of " + address + " is " + response.balance());\n\n            UtxoInput[] outputs = iota.getAddress().outputs(address, new OutputsOptions());\n            System.out.println("The outputs of address " + address + " are: " + Arrays.toString(outputs));\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void getOutputs() {\n        try {\n            Client iota = node();\n\n            String address = "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r";\n\n            UtxoInput[] outputs = iota.getAddress().outputs(address, new OutputsOptions());\n            System.out.println("The outputs of address " + address + " are: " + Arrays.toString(outputs));\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void simpleMessage() {\n        try {\n            Client iota = node();\n            Message message = iota.message().finish();\n\n            System.out.println(\n                    "Empty message sent: https://explorer.iota.org/mainnet/message/" + message.id().toString());\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void getMessageMetadata() {\n        try {\n            Client iota = node();\n            Message message = iota.message().finish();\n\n            MessageMetadata metadata = iota.getMessage().metadata(message.id());\n\n            System.out.println("Message metadata: " + metadata);\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void getDataMessage() {\n        Client iota = node();\n\n        Message message = iota.message().withIndexString("Hello").withDataString("Tangle").finish();\n\n        System.out.println("Message sent https://explorer.iota.org/devnet/message/" + message.id());\n\n        MessageId[] fetched_message_ids = iota.getMessage().indexString("Hello");\n        System.out.println("Messages with Hello index: " + Arrays.toString(fetched_message_ids));\n    }\n\n    public static void transaction() {\n        Client iota = node();\n\n        String seed_1 = "NONSECURE_USE_OF_DEVELOPMENT_SEED_1";\n\n        Message message = iota\n            .message()\n            .withSeed(seed_1)\n            // Insert the output address and amount to spent. The amount cannot be zero.\n            .withOutput(\n                // We generate an address from our seed so that we send the funds to ourselves\n                        iota.getAddresses(seed_1).withRange(0, 1).finish()[0], 1000000\n            ).finish();\n\n        System.out.println("Transaction sent: https://explorer.iota.org/devnet/message/" +  message.id());\n    }\n\n    public static void mqtt() {\n        Client iota = node();\n\n        MqttListener listener = new MqttListener() {\n            @Override\n            public void onEvent(TopicEvent event) {\n                System.out.println(event);\n            }\n        };\n\n        // TODO: Make listeners with the Sync trait\n        // iota.subscriber().withTopic(Topic.from("messages")).subscribe(listener);\n    }\n\n    public static void consolidate() {\n        Client iota = node();\n\n        String seed = "NONSECURE_USE_OF_DEVELOPMENT_SEED_1";\n\n        // Here all funds will be send to the address with the lowest index in the range\n        String address = Util.consolidateFunds(iota, seed, 0, 0, 150);\n\n        System.out.println("Funds consolidated to" + address);\n    }\n\n    public static void createMaxDust(){\n        Client iota = node();\n        String seed = "NONSECURE_USE_OF_DEVELOPMENT_SEED_1";\n        String seed_2 = "NONSECURE_USE_OF_DEVELOPMENT_SEED_2";\n\n        String[] new_addresses = iota.getAddresses(seed_2).withRange(0, 1).finish();\n\n        Message dustAllowanceMessage = iota\n            .message()\n            .withSeed(seed)\n            .withDustAllowanceOutput(new_addresses[0], 10_000_000)\n            .finish();\n\n        MessageWrap[] msgs = iota.retryUntilIncluded(dustAllowanceMessage.id(), -1, -1);\n\n        // Split funds to own addresses\n        String[] addresses = iota\n            .getAddresses(seed)\n            // We start from index 1 so we can send remaining balance to the address with index 0\n            .withRange(1, 101)\n            .finish();\n\n        ClientMessageBuilder message_builder = iota.message().withSeed(seed);\n        for (String address : addresses) {\n            // Make sure to re-set the builder as the instance is a clone of the old one due to JNI limits\n            message_builder = message_builder.withOutput(address, 1_000_001);\n        }\n        Message message = message_builder.finish();\n\n        System.out.println(\n            "First transaction sent: https://explorer.iota.org/devnet/message/" + message.id()\n        );\n\n        msgs = iota.retryUntilIncluded(message.id(), -1, -1);\n\n        // At this point we have 100 Mi on 100 addresses and we will just send it to the final address\n        // We use the outputs directly so we don\'t double spend them\n        \n        List<UtxoInput> initial_outputs = new ArrayList<>();\n        Optional<MessagePayload> payload = message.payload();\n        if (payload.isPresent() && payload.get().payloadType().equals(MessagePayloadType.TRANSACTION)) {\n            TransactionPayload tx = payload.get().asTransaction();\n            RegularEssence essence = tx.essence().asRegular();\n            Output[] outputs = essence.outputs();\n            for (int index = 0; index < outputs.length; index++) {\n                Output output = outputs[index];\n                if (output.asSignatureLockedSingleOutput().amount() == 1_000_001) {\n                    initial_outputs.add(UtxoInput.from(tx.id(), index));\n                } \n            }\n        }\n\n        String[] first_address_old_seed = iota.getAddresses(seed).withRange(0, 1).finish();\n        List<MessageId> sent_messages = new ArrayList<>();\n        for (UtxoInput input : initial_outputs) {\n            MessageId message_id = iota\n                .message()\n                    .withSeed(seed).withInput(input).withInputRange(1, 101).withOutput(new_addresses[0], 1)\n                // send remaining iotas back\n                    .withOutput(first_address_old_seed[0], 1_000_000)\n                .finish()\n                    .id();\n            System.out.printf("Transaction %i sent: https://explorer.iota.org/devnet/message/%s" + input.index(),\n                    message_id\n            );\n            sent_messages.add(message_id);\n        }\n        // only check last message, if this gets confirmed all other messages should also be confirmed\n        msgs = iota.retryUntilIncluded(sent_messages.get(sent_messages.size() - 1), -1, -1);\n        // Send all funds back to first address\n        long total_balance = iota.getBalance(seed).finish();\n\n        System.out.println("Total balance: " + total_balance);\n\n        message = iota\n            .message()\n            .withSeed(seed)\n            .withOutput(first_address_old_seed[0], total_balance)\n            .finish();\n\n        System.out.println("Final tx sent: https://explorer.iota.org/devnet/message/" + message.id());\n\n        msgs = iota.retryUntilIncluded(message.id(), -1, -1);\n    }\n\n    public static void customPayload() {\n        // Create a client instance\n        Client iota = node();\n\n        IndexationPayload indexation_payload = IndexationPayload.fromStrings("Your Index", "Your Data");\n\n        Message message = iota.message().finishIndex(indexation_payload);\n\n        System.out.printf("Message ID: %s", message.id());\n    }\n\n    public static void offlineExample() {\n        String seed = "NONSECURE_USE_OF_DEVELOPMENT_SEED_1";\n        String toAddress = "atoi1qruzprxum2934lr3p77t96pzlecxv8pjzvtjrzdcgh2f5exa22n6gek0qdq";\n        long amount = 1_000_000;\n\n        Offline offlineExample = new Offline(NODE, seed);\n        String[] inputAddresses = offlineExample.generateAddresses();\n        String preparedData = offlineExample.prepareTransaction(inputAddresses, toAddress, amount);\n        System.out.println("Prepared data: " + preparedData);\n        String signedData = offlineExample.signTransaction(preparedData);\n        System.out.println("Signed data: " + signedData);\n\n        Message message = offlineExample.sendMessage(signedData);\n\n        System.out.printf("Message ID: %s", message.id());\n    }\n}\n'}}]);