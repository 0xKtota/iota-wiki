"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[95388],{94645:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return l},default:function(){return y},frontMatter:function(){return u},metadata:function(){return p},toc:function(){return m}});var i=n(74034),a=n(79973),o=(n(67294),n(3905)),r=n(31137),d=n(71871),s=n(48235),c=["components"],u={title:"Update DID Documents",sidebar_label:"Update",description:"How DID Documents can be manipulated and how updates should be published",image:"/img/Identity_icon.png",keywords:["Documents","DID","Tangle","Update","Publish"]},l=void 0,p={unversionedId:"decentralized_identifiers/update",id:"decentralized_identifiers/update",isDocsHomePage:!1,title:"Update DID Documents",description:"How DID Documents can be manipulated and how updates should be published",source:"@site/external/identity.rs/documentation/docs/decentralized_identifiers/update.mdx",sourceDirName:"decentralized_identifiers",slug:"/decentralized_identifiers/update",permalink:"/identity.rs/decentralized_identifiers/update",editUrl:"https://github.com/iotaledger/identity.rs/edit/dev/external/identity.rs/documentation/docs/decentralized_identifiers/update.mdx",tags:[],version:"current",frontMatter:{title:"Update DID Documents",sidebar_label:"Update",description:"How DID Documents can be manipulated and how updates should be published",image:"/img/Identity_icon.png",keywords:["Documents","DID","Tangle","Update","Publish"]},sidebar:"docs",previous:{title:"Create and Publish",permalink:"/identity.rs/decentralized_identifiers/create"},next:{title:"Secure",permalink:"/identity.rs/decentralized_identifiers/secure"}},m=[{value:"Example",id:"example",children:[{value:"Account Module (Recommended)",id:"account-module-recommended",children:[],level:3},{value:"Low-level API",id:"low-level-api",children:[],level:3}],level:2}],h={toc:m};function y(e){var t=e.components,n=(0,a.Z)(e,c);return(0,o.kt)("wrapper",(0,i.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"TODO: Explain how DID Documents can be manipulated and how updates should be published."),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("p",null,"This example shows how you can add more to an existing DID Document. The two main things you can add are Verification Methods and Services. A verification method adds public keys, which can be used to digitally sign things like an identity. The services provide metadata around the identity via URIs. These can be URLs, but also emails or IOTA indices."),(0,o.kt)("h3",{id:"account-module-recommended"},"Account Module (Recommended)"),(0,o.kt)(s.Z,{className:"language-rust",mdxType:"CodeBlock"},'// Copyright 2020-2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! cargo run --example account_manipulate\n\nuse std::path::PathBuf;\n\nuse identity::account::Account;\nuse identity::account::AccountStorage;\nuse identity::account::IdentityCreate;\nuse identity::account::IdentityState;\nuse identity::account::Result;\nuse identity::core::Url;\nuse identity::did::MethodScope;\nuse identity::iota::IotaDID;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n  pretty_env_logger::init();\n\n  // ===========================================================================\n  // Create Identity - Similar to create_did example\n  // ===========================================================================\n\n  // Stronghold settings\n  let stronghold_path: PathBuf = "./example-strong.hodl".into();\n  let password: String = "my-password".into();\n\n  // Create a new Account with the default configuration\n  let account: Account = Account::builder()\n    .storage(AccountStorage::Stronghold(stronghold_path, Some(password)))\n    .build()\n    .await?;\n\n  // Create a new Identity with default settings\n  //\n  // This step generates a keypair, creates an identity and publishes it to the IOTA mainnet.\n  let identity: IdentityState = account.create_identity(IdentityCreate::default()).await?;\n  let iota_did: &IotaDID = identity.try_did()?;\n\n  // ===========================================================================\n  // Identity Manipulation\n  // ===========================================================================\n\n  // Add another Ed25519 verification method to the identity\n  account\n    .update_identity(&iota_did)\n    .create_method()\n    .fragment("my-next-key")\n    .apply()\n    .await?;\n\n  // Associate the newly created method with additional verification relationships\n  account\n    .update_identity(&iota_did)\n    .attach_method()\n    .fragment("my-next-key")\n    .scope(MethodScope::CapabilityDelegation)\n    .scope(MethodScope::CapabilityInvocation)\n    .apply()\n    .await?;\n\n  // Add a new service to the identity.\n  account\n    .update_identity(&iota_did)\n    .create_service()\n    .fragment("my-service-1")\n    .type_("MyCustomService")\n    .endpoint(Url::parse("https://example.com")?)\n    .apply()\n    .await?;\n\n  // Remove the Ed25519 verification method\n  account\n    .update_identity(&iota_did)\n    .delete_method()\n    .fragment("my-next-key")\n    .apply()\n    .await?;\n\n  // Prints the Identity Resolver Explorer URL, the entire history can be observed on this page by "Loading History".\n  println!(\n    "[Example] Explore the DID Document = {}{}",\n    iota_did.network()?.explorer_url().unwrap().to_string(),\n    iota_did.to_string()\n  );\n  Ok(())\n}\n'),(0,o.kt)("h3",{id:"low-level-api"},"Low-level API"),(0,o.kt)(r.Z,{groupId:"programming-languages",defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Node.js",value:"nodejs"}],mdxType:"Tabs"},(0,o.kt)(d.Z,{value:"rust",mdxType:"TabItem"},(0,o.kt)(s.Z,{className:"language-rust",mdxType:"CodeBlock"},'// Copyright 2020-2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! An example that demonstrates how to publish changes to the integration chain to update a\n//! DID Document.\n//!\n//! cargo run --example update_did\n\nuse identity::core::json;\nuse identity::core::FromJson;\nuse identity::core::Timestamp;\nuse identity::did::MethodScope;\nuse identity::did::Service;\nuse identity::did::DID;\nuse identity::iota::ClientMap;\nuse identity::iota::IotaVerificationMethod;\nuse identity::iota::Receipt;\nuse identity::iota::TangleRef;\nuse identity::prelude::*;\n\nmod create_did;\n\npub async fn run() -> Result<(IotaDocument, KeyPair, KeyPair, Receipt, Receipt)> {\n  // Create a client instance to send messages to the Tangle.\n  let client: ClientMap = ClientMap::new();\n\n  // Create a signed DID Document and KeyPair (see create_did.rs).\n  let (mut document, keypair, receipt): (IotaDocument, KeyPair, Receipt) = create_did::run().await?;\n\n  // Add a new VerificationMethod with a new keypair\n  let new_key: KeyPair = KeyPair::new_ed25519()?;\n  let method: IotaVerificationMethod = IotaVerificationMethod::from_did(document.did().clone(), &new_key, "newKey")?;\n  assert!(document.insert_method(MethodScope::VerificationMethod, method));\n\n  // Add a new Service\n  let service: Service = Service::from_json_value(json!({\n    "id": document.id().to_url().join("#linked-domain")?,\n    "type": "LinkedDomains",\n    "serviceEndpoint": "https://iota.org"\n  }))?;\n  assert!(document.insert_service(service));\n\n  // Add the messageId of the previous message in the chain.\n  // This is REQUIRED in order for the messages to form a chain.\n  // Skipping / forgetting this will render the publication useless.\n  document.set_previous_message_id(*receipt.message_id());\n  document.set_updated(Timestamp::now_utc());\n\n  // Sign the DID Document with the original private key.\n  document.sign(keypair.private())?;\n\n  // Publish the updated DID Document to the Tangle.\n  let update_receipt: Receipt = client.publish_document(&document).await?;\n\n  println!("Publish Receipt > {:#?}", update_receipt);\n\n  // Display the web explorer url that shows the published message.\n  println!("DID Document Transaction > {}", update_receipt.message_url()?);\n\n  Ok((document, keypair, new_key, receipt, update_receipt))\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n  let _ = run().await?;\n  Ok(())\n}\n')),(0,o.kt)(d.Z,{value:"nodejs",mdxType:"TabItem"},(0,o.kt)(s.Z,{className:"language-javascript",mdxType:"CodeBlock"},'// Copyright 2020-2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport {Client, Config, KeyPair, KeyType, VerificationMethod, Service, Timestamp} from \'@iota/identity-wasm\';\nimport {createIdentity} from "./create_did";\nimport {logExplorerUrl} from "./utils";\n\n/**\n This example shows how to add more to an existing DID Document.\n The two main things to add are Verification Methods and Services.\n A verification method adds public keys, which can be used to digitally sign things as an identity.\n The services provide metadata around the identity via URIs. These can be URLs, but can also emails or IOTA indices.\n An important detail to note is the previousMessageId:\n This is an important field as it links the new DID Document to the old DID Document, creating a chain.\n Without setting this value, the new DID Document won\'t get used during resolution of the DID!\n\n @param {{defaultNodeURL: string, explorerURL: string, network: Network}} clientConfig\n **/\nasync function manipulateIdentity(clientConfig) {\n    // Create a default client configuration from the parent config network.\n    const config = Config.fromNetwork(clientConfig.network);\n\n    // Create a client instance to publish messages to the Tangle.\n    const client = Client.fromConfig(config);\n\n    // Creates a new identity (see "create_did" example)\n    let {key, doc, receipt} = await createIdentity(clientConfig);\n\n    // Add a new VerificationMethod with a new KeyPair\n    const newKey = new KeyPair(KeyType.Ed25519);\n    const method = VerificationMethod.fromDID(doc.id, newKey, "newKey");\n    doc.insertMethod(method, "VerificationMethod");\n\n    // Add a new ServiceEndpoint\n    const serviceJSON = {\n        id: doc.id + "#linked-domain",\n        type: "LinkedDomains",\n        serviceEndpoint: "https://iota.org",\n    };\n    doc.insertService(Service.fromJSON(serviceJSON));\n\n    /*\n        Add the messageId of the previous message in the chain.\n        This is REQUIRED in order for the messages to form a chain.\n        Skipping / forgetting this will render the publication useless.\n    */\n    doc.previousMessageId = receipt.messageId;\n    doc.updated = Timestamp.nowUTC();\n\n    // Sign the DID Document with the appropriate key.\n    doc.sign(key);\n\n    // Publish the Identity to the IOTA Network, this may take a few seconds to complete Proof-of-Work.\n    const updateReceipt = await client.publishDocument(doc.toJSON());\n\n    // Log the results.\n    logExplorerUrl("Identity Update:", clientConfig.network.toString(), updateReceipt.messageId);\n    return {\n        key,\n        newKey,\n        doc,\n        originalMessageId: receipt.messageId,\n        updatedMessageId: updateReceipt.messageId,\n    };\n}\n\nexport {manipulateIdentity};\n'))))}y.isMDXComponent=!0},71871:function(e,t,n){var i=n(67294);t.Z=function(e){var t=e.children,n=e.hidden,a=e.className;return i.createElement("div",{role:"tabpanel",hidden:n,className:a},t)}},31137:function(e,t,n){n.d(t,{Z:function(){return p}});var i=n(74034),a=n(67294),o=n(5730),r=n(54179);var d=function(){var e=(0,a.useContext)(r.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},s=n(3978),c=n(86010),u="tabItem_1uMI";function l(e){var t,n,i,o=e.lazy,r=e.block,l=e.defaultValue,p=e.values,m=e.groupId,h=e.className,y=a.Children.map(e.children,(function(e){if((0,a.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),f=null!=p?p:y.map((function(e){var t=e.props;return{value:t.value,label:t.label}})),g=(0,s.lx)(f,(function(e,t){return e.value===t.value}));if(g.length>0)throw new Error('Docusaurus error: Duplicate values "'+g.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var v=null===l?l:null!=(t=null!=l?l:null==(n=y.find((function(e){return e.props.default})))?void 0:n.props.value)?t:null==(i=y[0])?void 0:i.props.value;if(null!==v&&!f.some((function(e){return e.value===v})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+f.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var w=d(),D=w.tabGroupChoices,I=w.setTabGroupChoices,b=(0,a.useState)(v),k=b[0],_=b[1],T=[],x=(0,s.o5)().blockElementScrollPositionUntilNextRender;if(null!=m){var C=D[m];null!=C&&C!==k&&f.some((function(e){return e.value===C}))&&_(C)}var S=function(e){var t=e.currentTarget,n=T.indexOf(t),i=f[n].value;i!==k&&(x(t),_(i),null!=m&&I(m,i))},A=function(e){var t,n=null;switch(e.key){case"ArrowRight":var i=T.indexOf(e.currentTarget)+1;n=T[i]||T[0];break;case"ArrowLeft":var a=T.indexOf(e.currentTarget)-1;n=T[a]||T[T.length-1]}null==(t=n)||t.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,c.Z)("tabs",{"tabs--block":r},h)},f.map((function(e){var t=e.value,n=e.label;return a.createElement("li",{role:"tab",tabIndex:k===t?0:-1,"aria-selected":k===t,className:(0,c.Z)("tabs__item",u,{"tabs__item--active":k===t}),key:t,ref:function(e){return T.push(e)},onKeyDown:A,onFocus:S,onClick:S},null!=n?n:t)}))),o?(0,a.cloneElement)(y.filter((function(e){return e.props.value===k}))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},y.map((function(e,t){return(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==k})}))))}function p(e){var t=(0,o.Z)();return a.createElement(l,(0,i.Z)({key:String(t)},e))}},54179:function(e,t,n){var i=(0,n(67294).createContext)(void 0);t.Z=i}}]);