"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[30958],{71634:function(e,n,t){t.r(n),t.d(n,{assets:function(){return p},contentTitle:function(){return l},default:function(){return f},frontMatter:function(){return c},metadata:function(){return u},toc:function(){return m}});var r=t(87462),o=t(63366),s=(t(67294),t(3905)),i=t(87308),a=t(42526),d=["components"],c={title:"How To Generate Addresses"},l=void 0,u={unversionedId:"libraries/nodejs/how_to/generate_addresses",id:"libraries/nodejs/how_to/generate_addresses",title:"How To Generate Addresses",description:"",source:"@site/content/build/iota.rs/develop/documentation/docs/libraries/nodejs/how_to/4_generate_addresses.mdx",sourceDirName:"libraries/nodejs/how_to",slug:"/libraries/nodejs/how_to/generate_addresses",permalink:"/iota.rs/develop/libraries/nodejs/how_to/generate_addresses",draft:!1,editUrl:"https://github.com/iotaledger/iota.rs/edit/develop/documentation/content/build/iota.rs/develop/documentation/docs/libraries/nodejs/how_to/4_generate_addresses.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"How To Generate Addresses"},sidebar:"docs",previous:{title:"How To Generate A Mnemonic",permalink:"/iota.rs/develop/libraries/nodejs/how_to/generate_mnemonic"},next:{title:"How To Create A Block",permalink:"/iota.rs/develop/libraries/nodejs/how_to/create_block"}},p={},m=[],g={toc:m};function f(e){var n=e.components,t=(0,o.Z)(e,d);return(0,s.kt)("wrapper",(0,r.Z)({},g,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)(i.Z,{className:"language-typescript",mdxType:"CodeBlock"},"// Copyright 2021-2022 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\nimport {\n    Client,\n    CoinType,\n    initLogger,\n    SHIMMER_TESTNET_BECH32_HRP,\n} from '@iota/client';\nrequire('dotenv').config({ path: '../.env' });\n\n// Run with command:\n// node ./dist/02_generate_addresses.js\n\n// In this example we will create addresses from a mnemonic defined in .env\nasync function run() {\n    initLogger();\n    if (!process.env.NODE_URL) {\n        throw new Error('.env NODE_URL is undefined, see .env.example');\n    }\n\n    const client = new Client({\n        // Insert your node URL in the .env.\n        nodes: [process.env.NODE_URL],\n    });\n\n    try {\n        if (!process.env.NON_SECURE_USE_OF_DEVELOPMENT_MNEMONIC_1) {\n            throw new Error('.env mnemonic is undefined, see .env.example');\n        }\n        const secretManager = {\n            Mnemonic: process.env.NON_SECURE_USE_OF_DEVELOPMENT_MNEMONIC_1,\n        };\n\n        // Generate public address with custom account index and range.\n        const address = await client.generateAddresses(secretManager, {\n            accountIndex: 0,\n            range: {\n                start: 0,\n                end: 1,\n            },\n        });\n        console.log('First public address:', address, '\\n');\n\n        // Generate an internal address with custom account index and range.\n        const internalAddress = await client.generateAddresses(secretManager, {\n            accountIndex: 0,\n            range: {\n                start: 0,\n                end: 1,\n            },\n            internal: true,\n        });\n        console.log('First internal address:', internalAddress, '\\n');\n\n        // Generate addresses with providing all inputs, that way it can also be done offline without a node.\n        const offlineGeneratedAddresses = await client.generateAddresses(\n            secretManager,\n            {\n                coinType: CoinType.Shimmer,\n                accountIndex: 0,\n                range: {\n                    start: 0,\n                    end: 2,\n                },\n                internal: false,\n                // Generating addresses with client.generateAddresses(secretManager, {}), will by default get the bech32_hrp (Bech32\n                // human readable part) from the nodeinfo, generating it \"offline\" requires setting it in the generateAddressesOptions\n                bech32Hrp: SHIMMER_TESTNET_BECH32_HRP,\n            },\n        );\n        console.log(\n            'List of offline generated public addresses:',\n            offlineGeneratedAddresses,\n        );\n    } catch (error) {\n        console.error('Error: ', error);\n    }\n}\n\nrun().then(() => process.exit());\n"),(0,s.kt)(a.ZP,{mdxType:"MoreExamples"}))}f.isMDXComponent=!0},42526:function(e,n,t){t.d(n,{ZP:function(){return d}});var r=t(87462),o=t(63366),s=(t(67294),t(3905)),i=["components"],a={toc:[]};function d(e){var n=e.components,t=(0,o.Z)(e,i);return(0,s.kt)("wrapper",(0,r.Z)({},a,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"More advanced examples can be found in the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/iota.rs/tree/develop/bindings/nodejs/examples"},"examples")," folder."))}d.isMDXComponent=!0}}]);