"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[83992],{66015:function(e,t,n){n.r(t),n.d(t,{assets:function(){return u},contentTitle:function(){return d},default:function(){return f},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return h}});var i=n(83117),a=n(80102),r=(n(67294),n(3905)),s=n(46624),o=["components"],l={title:"Verifiable Presentations",sidebar_label:"Verifiable Presentations",description:"Explain how a VC is created and verified",image:"/img/Identity_icon.png",keywords:["verifiable","presentations"]},d=void 0,c={unversionedId:"verifiable_credentials/verifiable_presentations",id:"verifiable_credentials/verifiable_presentations",title:"Verifiable Presentations",description:"Explain how a VC is created and verified",source:"@site/external/identity.rs/documentation/docs/verifiable_credentials/verifiable_presentations.mdx",sourceDirName:"verifiable_credentials",slug:"/verifiable_credentials/verifiable_presentations",permalink:"/identity.rs/verifiable_credentials/verifiable_presentations",editUrl:"https://github.com/iotaledger/identity.rs/edit/dev/external/identity.rs/documentation/docs/verifiable_credentials/verifiable_presentations.mdx",tags:[],version:"current",frontMatter:{title:"Verifiable Presentations",sidebar_label:"Verifiable Presentations",description:"Explain how a VC is created and verified",image:"/img/Identity_icon.png",keywords:["verifiable","presentations"]},sidebar:"docs",previous:{title:"Revocation",permalink:"/identity.rs/verifiable_credentials/revoke"},next:{title:"Overview",permalink:"/identity.rs/did_communications/overview"}},u={},h=[{value:"Example",id:"example",level:2}],p={toc:h};function f(e){var t=e.components,n=(0,a.Z)(e,o);return(0,r.kt)("wrapper",(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"TODO: Explain the need for and"),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,"This example shows how you can create and validate a Verifiable Presentation. A Verifiable Presentation is the format in which you can share a (collection of) Verifiable Credential(s). It is signed by the subject, to prove control over the Verifiable Credential with a nonce or timestamp."),(0,r.kt)(s.Z,{nodeReplitLink:"https://repl.it/@IOTAFoundation/create-vp?lite=true",rustContent:'// Copyright 2020-2022 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! A Verifiable Presentation (VP) represents a bundle of one or more Verifiable Credentials.\n//! This example demonstrates building and usage of VPs.\n//!\n//! cargo run --example account_create_vp\n\nuse identity::account::Account;\nuse identity::account::AccountBuilder;\nuse identity::account::IdentitySetup;\nuse identity::account::MethodContent;\nuse identity::core::json;\nuse identity::core::Duration;\nuse identity::core::FromJson;\nuse identity::core::Timestamp;\nuse identity::core::ToJson;\nuse identity::core::Url;\nuse identity::credential::Credential;\nuse identity::credential::CredentialBuilder;\nuse identity::credential::Presentation;\nuse identity::credential::PresentationBuilder;\nuse identity::credential::Subject;\nuse identity::crypto::ProofOptions;\nuse identity::did::verifiable::VerifierOptions;\n\nuse identity::account::Result;\nuse identity::iota::CredentialValidationOptions;\nuse identity::iota::FailFast;\nuse identity::iota::PresentationValidationOptions;\n\nuse identity::iota::Resolver;\nuse identity::iota::SubjectHolderRelationship;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n  // ===========================================================================\n  // Step 1: Create identities for the issuer and the holder.\n  // ===========================================================================\n\n  // Create an account builder with in-memory storage for simplicity.\n  // See `create_did` example to configure Stronghold storage.\n  let mut builder: AccountBuilder = Account::builder();\n\n  // Create an identity for the issuer.\n  let mut issuer: Account = builder.create_identity(IdentitySetup::default()).await?;\n\n  // Add a dedicated verification method to the issuer, with which to sign credentials.\n  issuer\n    .update_identity()\n    .create_method()\n    .content(MethodContent::GenerateEd25519)\n    .fragment("issuerKey")\n    .apply()\n    .await?;\n\n  // Create an identity for the holder, in this case also the subject.\n  let mut alice: Account = builder.create_identity(IdentitySetup::default()).await?;\n\n  // Add verification method to the holder.\n  alice\n    .update_identity()\n    .create_method()\n    .content(MethodContent::GenerateEd25519)\n    .fragment("aliceKey")\n    .apply()\n    .await?;\n\n  // ===========================================================================\n  // Step 2: Issuer creates and signs a Verifiable Credential.\n  // ===========================================================================\n\n  // Create VC "subject" field containing subject ID and claims about it.\n  let subject: Subject = Subject::from_json_value(json!({\n    "id": alice.did().to_string(),\n    "name": "Alice",\n    "degree": {\n      "type": "BachelorDegree",\n      "name": "Bachelor of Science and Arts",\n    },\n    "GPA": "4.0",\n  }))?;\n\n  // Build credential using subject above and issuer.\n  let mut credential: Credential = CredentialBuilder::default()\n    .id(Url::parse("https://example.edu/credentials/3732")?)\n    .issuer(Url::parse(issuer.did().to_string())?)\n    .type_("UniversityDegreeCredential")\n    .subject(subject)\n    .build()?;\n\n  // Sign the Credential with the issuers default key.\n  issuer\n    .sign("#issuerKey", &mut credential, ProofOptions::default())\n    .await?;\n\n  println!("Credential JSON > {:#}", credential);\n\n  // ===========================================================================\n  // Step 3: Issuer sends the Verifiable Credential to the holder.\n  // ===========================================================================\n\n  // The credential is then serialized to JSON and transmitted to the holder in a secure manner.\n  // Note that the credential is NOT published to the IOTA Tangle. It is sent and stored off-chain.\n  let credential_json: String = credential.to_json()?;\n\n  // ===========================================================================\n  // Step 4: Verifier sends the holder a challenge and requests a signed Verifiable Presentation.\n  // ===========================================================================\n\n  // A unique random challenge generated by the requester per presentation can mitigate replay attacks\n  let challenge: &str = "475a7984-1bb5-4c4c-a56f-822bccd46440";\n\n  // The verifier and holder also agree that the signature should have an expiry date\n  // 10 minutes from now.\n  let expires: Timestamp = Timestamp::now_utc().checked_add(Duration::minutes(10)).unwrap();\n\n  // ===========================================================================\n  // Step 5: Holder creates and signs a verifiable presentation from the issued credential.\n  // ===========================================================================\n\n  // Deserialize the credential.\n  let credential: Credential = Credential::from_json(credential_json.as_str())?;\n\n  // Create an unsigned Presentation from the previously issued Verifiable Credential.\n  let mut presentation: Presentation = PresentationBuilder::default()\n    .holder(Url::parse(alice.did().as_ref())?)\n    .credential(credential)\n    .build()?;\n\n  // Sign the verifiable presentation using the holder\'s verification method\n  // and include the requested challenge and expiry timestamp.\n  alice\n    .sign(\n      "#aliceKey",\n      &mut presentation,\n      ProofOptions::new().challenge(challenge.to_string()).expires(expires),\n    )\n    .await?;\n\n  // ===========================================================================\n  // Step 6: Holder sends a verifiable presentation to the verifier.\n  // ===========================================================================\n\n  // Convert the Verifiable Presentation to JSON to send it to the verifier.\n  let presentation_json: String = presentation.to_json()?;\n\n  // ===========================================================================\n  // Step 7: Verifier receives the Verifiable Presentation and verifies it.\n  // ===========================================================================\n\n  // Deserialize the presentation from the holder:\n  let presentation: Presentation = Presentation::from_json(&presentation_json)?;\n\n  // The verifier wants the following requirements to be satisfied:\n  // - Signature verification (including checking the requested challenge to mitigate replay attacks)\n  // - Presentation validation must fail if credentials expiring within the next 10 hours are encountered\n  // - The presentation holder must always be the subject, regardless of the presence of the nonTransferable property\n  // - The issuance date must not be in the future.\n\n  let presentation_verifier_options: VerifierOptions = VerifierOptions::new()\n    .challenge(challenge.to_owned())\n    .allow_expired(false);\n\n  // Do not allow credentials that expire within the next 10 hours.\n  let credential_validation_options: CredentialValidationOptions = CredentialValidationOptions::default()\n    .earliest_expiry_date(Timestamp::now_utc().checked_add(Duration::hours(10)).unwrap());\n\n  let presentation_validation_options = PresentationValidationOptions::default()\n    .presentation_verifier_options(presentation_verifier_options.clone())\n    .shared_validation_options(credential_validation_options)\n    .subject_holder_relationship(SubjectHolderRelationship::AlwaysSubject);\n\n  // Validate the presentation and all the credentials included in it.\n  let resolver: Resolver = Resolver::new().await?;\n  resolver\n    .verify_presentation(\n      &presentation,\n      &presentation_validation_options,\n      FailFast::FirstError,\n      None,\n      None,\n    )\n    .await?;\n\n  // Since no errors were thrown by `verify_presentation` we know that the validation was successful.\n  println!("VP successfully validated");\n\n  // Note that we did not declare a latest allowed issuance date for credentials. This is because we only want to check\n  // that the credentials do not have an issuance date in the future which is a default check.\n\n  Ok(())\n}\n',nodeGithubLink:"https://github.com/iotaledger/identity.rs/blob/dev/bindings/wasm/examples-account/src/create_vp.ts",rustGithubLink:"https://github.com/iotaledger/identity.rs/blob/dev/examples/account/create_vp.rs",mdxType:"CodeSnippet"}))}f.isMDXComponent=!0},46624:function(e,t,n){n.d(t,{Z:function(){return s}});var i=n(86010),a=n(67294),r=n(55990);function s(e){var t=e.nodeReplitLink,n=e.rustContent,s=e.nodeGithubLink,o=e.rustGithubLink,l=a.useState("node"),d=l[0],c=l[1],u=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"12",height:"12",fill:"currentColor",class:"bi bi-box-arrow-up-right",viewBox:"0 0 16 16"},a.createElement("path",{"fill-rule":"evenodd",d:"M8.636 3.5a.5.5 0 0 0-.5-.5H1.5A1.5 1.5 0 0 0 0 4.5v10A1.5 1.5 0 0 0 1.5 16h10a1.5 1.5 0 0 0 1.5-1.5V7.864a.5.5 0 0 0-1 0V14.5a.5.5 0 0 1-.5.5h-10a.5.5 0 0 1-.5-.5v-10a.5.5 0 0 1 .5-.5h6.636a.5.5 0 0 0 .5-.5z"}),a.createElement("path",{"fill-rule":"evenodd",d:"M16 .5a.5.5 0 0 0-.5-.5h-5a.5.5 0 0 0 0 1h3.793L6.146 9.146a.5.5 0 1 0 .708.708L15 1.707V5.5a.5.5 0 0 0 1 0v-5z"}));return(0,a.useEffect)((function(){var e=localStorage.getItem("lang"),i=e||"node";"node"!==i||t||(i="rust"),"rust"!==i||n||(i="node"),c(i)})),a.createElement("div",null,a.createElement("div",{className:(0,i.Z)("langSelector")},t&&a.createElement("button",{className:(0,i.Z)("button","languageButton","mr-sm",{activeButton:"node"===d,inactiveButton:"node"!==d}),onClick:function(){localStorage.setItem("lang","node"),c("node")}},"Node.js"),n&&a.createElement("button",{className:(0,i.Z)("button","languageButton",{activeButton:"rust"==d,inactiveButton:"rust"!==d}),onClick:function(){localStorage.setItem("lang","rust"),c("rust")}},"Rust")),a.createElement("div",{className:(0,i.Z)("codeSnippetContainer")},"node"===d?a.createElement(a.Fragment,null,a.createElement("iframe",{frameborder:"0",width:"100%",height:"700px",src:t})):a.createElement("div",{className:(0,i.Z)("rustContainer")},a.createElement(r.Z,{className:(0,i.Z)("noMarginBottom"),language:"rust"},n))),a.createElement("div",{className:(0,i.Z)("githubLink")},s&&"node"===d&&a.createElement("a",{href:s,target:"_blank"},"GitHub\xa0",u),o&&"rust"===d&&a.createElement("a",{href:o,target:"_blank"},"GitHub\xa0",u)))}}}]);