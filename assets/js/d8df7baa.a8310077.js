"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[3085],{37930:function(e,n,t){t.r(n),t.d(n,{assets:function(){return D},contentTitle:function(){return j},default:function(){return Z},frontMatter:function(){return O},metadata:function(){return M},toc:function(){return q}});var a=t(87462),s=t(63366),i=(t(67294),t(3905)),r=t(34259),d=t(18679),l=["components"],o={toc:[]};function c(e){var n=e.components,t=(0,s.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},o,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("admonition",{title:"Faucet Service",type:"note"},(0,i.kt)("p",{parentName:"admonition"},"You can use the ",(0,i.kt)("a",{parentName:"p",href:"https://faucet.chrysalis-devnet.iota.cafe/"},"faucet service")," to send test tokens to any Chrysalis\n",(0,i.kt)("a",{parentName:"p",href:"https://wiki.iota.org/chrysalis-docs/devnet"},"devnet")," address.")))}c.isMDXComponent=!0;var p=t(69319),u=t(94365),m=["components"],g=u.Z.indexOf("public static void getBalance() {"),h=u.Z.indexOf(" public static void getOutputs() {"),f=u.Z.substring(g,h),b={toc:[{value:"<code>Client.getBalance(seed: String)</code>",id:"clientgetbalanceseed-string",level:2},{value:"<code>Client.getAddressBalance(address: String)</code>",id:"clientgetaddressbalanceaddress-string",level:2},{value:"<code>Client.getAddressBalances(addresses: String[])</code>",id:"clientgetaddressbalancesaddresses-string",level:2},{value:"<code>Client.getAddress().balance(address: String)</code>",id:"clientgetaddressbalanceaddress-string-1",level:2},{value:"<code>Client.getAddress().outputs(address: String, options: OutputOptions)</code>",id:"clientgetaddressoutputsaddress-string-options-outputoptions",level:2}]};function k(e){var n=e.components,t=(0,s.Z)(e,m);return(0,i.kt)("wrapper",(0,a.Z)({},b,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"clientgetbalanceseed-string"},(0,i.kt)("a",{parentName:"h2",href:"./../libraries/java/api_reference#getbalanceseed-getbalancebuilderapi"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.getBalance(seed: String)"))),(0,i.kt)("p",null,"Combines ",(0,i.kt)("a",{parentName:"p",href:"./../libraries/java/api_reference#getaddressesseed-getaddressesbuilder"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.getAddresses()"))," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"Client.getAddressBalance()")," api calls. It returns a combined balance for the provided ",(0,i.kt)("inlineCode",{parentName:"p"},"seed"),"."),(0,i.kt)("h2",{id:"clientgetaddressbalanceaddress-string"},(0,i.kt)("a",{parentName:"h2",href:"./../libraries/java/api_reference#getaddressbalanceaddress-balanceaddressresponse"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.getAddressBalance(address: String)"))),(0,i.kt)("p",null,"Expects a single address in Bech32 format and returns ",(0,i.kt)("inlineCode",{parentName:"p"},"dict")," with a balance for the address."),(0,i.kt)("h2",{id:"clientgetaddressbalancesaddresses-string"},(0,i.kt)("a",{parentName:"h2",href:"./../libraries/java/api_reference#getaddressesbalancesaddresses-balanceaddressresponse"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.getAddressBalances(addresses: String[])"))),(0,i.kt)("p",null,"A convenient function that expects ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," of addresses in Bech32 format and returns list of ",(0,i.kt)("inlineCode",{parentName:"p"},"dict")," with balances for all\ngiven addresses."),(0,i.kt)("h2",{id:"clientgetaddressbalanceaddress-string-1"},(0,i.kt)("a",{parentName:"h2",href:"./../libraries/java/api_reference#balanceaddress-balanceaddressresponse"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.getAddress().balance(address: String)"))),(0,i.kt)("p",null,"You can use the ",(0,i.kt)("a",{parentName:"p",href:"./../libraries/java/api_reference#getaddressesbuilder"},(0,i.kt)("inlineCode",{parentName:"a"},"GetAdressBuilder"))," on a ",(0,i.kt)("inlineCode",{parentName:"p"},"Client")," instance and\nquery for and addresses' balances by chaining a call to the ",(0,i.kt)("inlineCode",{parentName:"p"},"balance(address: String)")," function."),(0,i.kt)("h2",{id:"clientgetaddressoutputsaddress-string-options-outputoptions"},(0,i.kt)("a",{parentName:"h2",href:"./../libraries/java/api_reference#outputsaddress-options-balanceaddressresponse"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.getAddress().outputs(address: String, options: OutputOptions)"))),(0,i.kt)("p",null,"You can use the ",(0,i.kt)("a",{parentName:"p",href:"./../libraries/java/api_reference#getaddressesbuilde"},(0,i.kt)("inlineCode",{parentName:"a"},"GetAdressBuilder"))," on a ",(0,i.kt)("inlineCode",{parentName:"p"},"Client")," instance and\nquery for and addresses' balances by chaining a call to the ",(0,i.kt)("inlineCode",{parentName:"p"},"outputs(address: String)")," function."),(0,i.kt)(p.Z,{className:"language-java",mdxType:"CodeBlock"},f),(0,i.kt)("p",null,"Example output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'Account balance: 1096055332i\n\nThe balance of "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r" is 451055332i\n\nThe outputs of address "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r" are: [\n  UtxoInput(741673db85f78ebd95d04b572d1bf32e9207bbd265d90dbbe499a6d32f2b25470000),\n  UtxoInput(ed33089c623c67eb06dbc1c10b0c1c0424b0ace04a2e44070702668b3de440c80000),\n  UtxoInput(0af84c860dc461730064e7c4c88152ed8bea1ae72b1d6f5e4ab0c3e51ed185b70100),\n  ...]\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dustAllowed")," indicates whether the given address is allowed to accept a dust. You can learn more about dust\nprotection in the\n",(0,i.kt)("a",{parentName:"li",href:"https://wiki.iota.org/chrysalis-docs/faq#what-is-dust-protection-and-how-does-it-work"},"Chrysalis documentation"),".")))}k.isMDXComponent=!0;var _=["components"],C={toc:[{value:"<code>Client.getAddressBalance(address: string)</code>",id:"clientgetaddressbalanceaddress-string",level:2},{value:"<code>Client.getAddressBalances(AddressBalance[]: string[])</code>",id:"clientgetaddressbalancesaddressbalance-string",level:2},{value:"<code>Client.getBalance(seed: string)</code>",id:"clientgetbalanceseed-string",level:2}]};function v(e){var n=e.components,t=(0,s.Z)(e,_);return(0,i.kt)("wrapper",(0,a.Z)({},C,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"There are three common API calls you can use to get a balance:"),(0,i.kt)("h2",{id:"clientgetaddressbalanceaddress-string"},(0,i.kt)("a",{parentName:"h2",href:"./../libraries/nodejs/api_reference#getaddressbalanceaddress-promise"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.getAddressBalance(address: string)"))),(0,i.kt)("p",null,"It expects a single address in Bech32 format and returns ",(0,i.kt)("inlineCode",{parentName:"p"},"dict")," with a balance for the address."),(0,i.kt)("h2",{id:"clientgetaddressbalancesaddressbalance-string"},(0,i.kt)("a",{parentName:"h2",href:"./../libraries/nodejs/api_reference#getaddressbalancesaddresses-promiseaddressbalance"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.getAddressBalances(AddressBalance[]: string[])"))),(0,i.kt)("p",null,"A convenient function that expects ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," of addresses in Bech32 format and returns list of ",(0,i.kt)("inlineCode",{parentName:"p"},"dict")," with balances for all\ngiven addresses."),(0,i.kt)("h2",{id:"clientgetbalanceseed-string"},(0,i.kt)("a",{parentName:"h2",href:"./../libraries/nodejs/api_reference#getbalanceseed-string-balancegetter"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.getBalance(seed: string)"))),(0,i.kt)("p",null,"A convenient helper ",(0,i.kt)("a",{parentName:"p",href:"./../libraries/nodejs/api_reference#balancegetter"},(0,i.kt)("inlineCode",{parentName:"a"},"BalanceGetter"))," class that combines\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/nodejs/api_reference#getaddressesseed-addressgetter"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.getAddresses()"))," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"Client.getAddressBalance()")," api calls. It returns a combined balance for the provided ",(0,i.kt)("inlineCode",{parentName:"p"},"seed")," and optional chaining\ncalls ",(0,i.kt)("a",{parentName:"p",href:"./../libraries/nodejs/api_reference#accountindexindex-balancegetter"},(0,i.kt)("inlineCode",{parentName:"a"},".accountIndex(index: number)")),",\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/nodejs/api_reference#initialaddressindexindex-balancegetter"},(0,i.kt)("inlineCode",{parentName:"a"},".initialAddressIndex(index: number)"))," and\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/nodejs/api_reference#gaplimitamount-balancegetter"},(0,i.kt)("inlineCode",{parentName:"a"},".gapLimit(amount: number)")),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Client.getBalance(seed)")," performs several tasks under the hood. It starts by generating addresses for the provided\n",(0,i.kt)("inlineCode",{parentName:"p"},"seed")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".accountIndex")," from ",(0,i.kt)("inlineCode",{parentName:"p"},".initialAddressIndex(index)"),", and checks for a balance of each of the generated\naddresses. Since it does not know how many addresses are used in fact, there is a condition set by the\n",(0,i.kt)("inlineCode",{parentName:"p"},".gapLimit(amount)")," argument to know when to stop searching. If the ",(0,i.kt)("inlineCode",{parentName:"p"},".gapLimit")," amount of addresses in a row have no\nbalance, the function returns results and searching does not continue."),(0,i.kt)(p.Z,{className:"language-javascript",mdxType:"CodeBlock"},'async function run() {\n    const { ClientBuilder } = require(\'@iota/client\');\n\n    // Get the seed from environment variable\n    const IOTA_SEED_SECRET = process.env.IOTA_SEED_SECRET;\n\n    // client will connect to testnet by default\n    const client = new ClientBuilder().build();\n\n    // Get the balance of a single known address\n    console.log(\n        await client.getAddressBalance("atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86")\n    );\n\n    // Get the balance of addresses from an account\n    const balance = await client.getBalance(IOTA_SEED_SECRET)\n        .accountIndex(0)\n        .initialAddressIndex(0)\n        .get();\n\n    console.log("Account balance: " + balance);\n}\n\nrun()\n'),(0,i.kt)("p",null,"Example of output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n   "address":"atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86",\n   "balance":10000000,\n   "dustAllowed":false\n}\nAccount balance: 0\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dustAllowed")," indicates whether the given address is allowed to accept a dust. You can learn more about dust\nprotection in the\n",(0,i.kt)("a",{parentName:"li",href:"https://wiki.iota.org/chrysalis-docs/faq#what-is-dust-protection-and-how-does-it-work"},"Chrysalis documentation"),".")))}v.isMDXComponent=!0;var N=["components"],y={toc:[{value:"<code>Client.get_address_balance(address: str)</code>",id:"clientget_address_balanceaddress-str",level:2},{value:"<code>Client.get_address_balances(addresses: list[str])</code>:",id:"clientget_address_balancesaddresses-liststr",level:2},{value:"<code>Client.get_balance(seed, account_index (optional), initial_address_index(optional), gap_limit(optional))</code>",id:"clientget_balanceseed-account_index-optional-initial_address_indexoptional-gap_limitoptional",level:2}]};function w(e){var n=e.components,t=(0,s.Z)(e,N);return(0,i.kt)("wrapper",(0,a.Z)({},y,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"There are three common API calls you can use to get a balance:"),(0,i.kt)("h2",{id:"clientget_address_balanceaddress-str"},(0,i.kt)("a",{parentName:"h2",href:"./../libraries/python/api_reference#get_address_balanceaddress-balanceaddressresponse"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.get_address_balance(address: str)"))),(0,i.kt)("p",null,"Expects a single address in Bech32 format and returns ",(0,i.kt)("inlineCode",{parentName:"p"},"dict")," with a balance for the address."),(0,i.kt)("h2",{id:"clientget_address_balancesaddresses-liststr"},(0,i.kt)("a",{parentName:"h2",href:"./../libraries/python/api_reference#get_address_balancesaddresses-listaddressbalancepair"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.get_address_balances(addresses: list[str])")),":"),(0,i.kt)("p",null,"A convenient function that expects ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," of addresses in Bech32 format and returns list of ",(0,i.kt)("inlineCode",{parentName:"p"},"dict")," with balances for all given addresses"),(0,i.kt)("h2",{id:"clientget_balanceseed-account_index-optional-initial_address_indexoptional-gap_limitoptional"},(0,i.kt)("a",{parentName:"h2",href:"./../libraries/python/api_reference#get_balanceseed-account_index-optional-initial_address_indexoptional-gap_limitoptional-int"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.get_balance(seed, account_index (optional), initial_address_index(optional), gap_limit(optional))"))),(0,i.kt)("p",null,"A convenient function that combines ",(0,i.kt)("inlineCode",{parentName:"p"},"Client.get_addresses()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Client.get_address_balances()")," api calls. It returns a combined balance for the provided ",(0,i.kt)("inlineCode",{parentName:"p"},"seed")," and optional chaining calls ",(0,i.kt)("inlineCode",{parentName:"p"},".accountIndex(index)"),", ",(0,i.kt)("inlineCode",{parentName:"p"},".initialAddressIndex(index)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".gapLimit(amount)")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Client.get_balance(seed)")," performs several tasks under the hood. It starts by generating addresses for the provided\n",(0,i.kt)("inlineCode",{parentName:"p"},"seed")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"account_index")," from ",(0,i.kt)("inlineCode",{parentName:"p"},"initial_address_index"),", and checks for a balance of each of the generated\naddresses. Since it does not know how many addresses are used in fact, there is a condition set by the\n",(0,i.kt)("inlineCode",{parentName:"p"},"gap_limit")," argument to know when to stop searching. If the ",(0,i.kt)("inlineCode",{parentName:"p"},"gap_limit")," amount of addresses in a row have no\nbalance, the function returns results and stops searching."),(0,i.kt)(p.Z,{className:"language-javascript",mdxType:"CodeBlock"},'import os\nimport iota_client\n\n# Get the seed from environment variable\nIOTA_SEED_SECRET = os.getenv(\'IOTA_SEED_SECRET\')\nif not IOTA_SEED_SECRET:\n    raise Exception("Please define environment variable called `IOTA_SEED_SECRET`")\n\nclient = iota_client.Client()\n\nprint("Return a balance for a single address:")\nprint(\n    client.get_address_balance("atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86")\n)\n\nprint("Return a balance for the given seed and account_index:")\nprint(\n    client.get_balance(\n        seed=IOTA_SEED_SECRET,\n        account_index=0,\n        initial_address_index=0\n    )\n)\n'),(0,i.kt)("p",null,"Example of output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n   "address":"atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86",\n   "balance":10000000,\n   "dustAllowed":false\n}\nAccount balance: 0\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dustAllowed")," indicates whether the given address is allowed to accept a dust due to\n",(0,i.kt)("a",{parentName:"li",href:"https://wiki.iota.org/chrysalis-docs/faq#what-is-dust-protection-and-how-does-it-work"},"dust protection mechanism"),".")))}w.isMDXComponent=!0;var x=["components"],E={toc:[{value:"<code>Client. get_address_balances(addresses: &amp;[String])</code>",id:"client-get_address_balancesaddresses-string",level:2},{value:"<code>Client.get_balance(seed: seed: &amp;&#39;a Seed)</code>",id:"clientget_balanceseed-seed-a-seed",level:2},{value:"<code>Client.get_address().balance(address: &amp;str)</code>",id:"clientget_addressbalanceaddress-str",level:2},{value:"<code>Client.get_address().outputs(address: &amp;str, options: OutputOptions)</code>",id:"clientget_addressoutputsaddress-str-options-outputoptions",level:2}]};function S(e){var n=e.components,t=(0,s.Z)(e,x);return(0,i.kt)("wrapper",(0,a.Z)({},E,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"There are several API calls you can use to get a balance:"),(0,i.kt)("h2",{id:"client-get_address_balancesaddresses-string"},(0,i.kt)("a",{parentName:"h2",href:"https://docs.rs/iota-client/latest/iota_client/client/struct.Client.html#method.get_address_balances"},(0,i.kt)("inlineCode",{parentName:"a"},"Client. get_address_balances(addresses: &[String])"))),(0,i.kt)("p",null,"Aconvenient function that expects ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," of addresses in Bech32 format and returns list of ",(0,i.kt)("inlineCode",{parentName:"p"},"dict")," with balances for all\ngiven addresses."),(0,i.kt)("h2",{id:"clientget_balanceseed-seed-a-seed"},(0,i.kt)("a",{parentName:"h2",href:"https://docs.rs/iota-client/latest/iota_client/client/struct.Client.html#method.get_balance"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.get_balance(seed: seed: &'a Seed)"))),(0,i.kt)("p",null,"A convenient ",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/iota-client/latest/iota_client/api/struct.GetBalanceBuilder.html#"},(0,i.kt)("inlineCode",{parentName:"a"},"GetBalanceBuilder")),"\nclass that combines\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/iota-client/latest/iota_client/client/struct.Client.html#method.get_addresses"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.get_addresses(seed: &'a Seed)")),"\nand\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/iota-client/latest/iota_client/client/struct.Client.html#method.get_address_balances"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.get_address_balances(addresses: &[String])")),"\napi calls. It returns a combined balance for the provided ",(0,i.kt)("inlineCode",{parentName:"p"},"seed")," and optional chaining calls\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/iota-client/latest/iota_client/api/struct.GetBalanceBuilder.html#method.with_account_index"},(0,i.kt)("inlineCode",{parentName:"a"},".with_account_index(account_index: usize)")),",\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/iota-client/latest/iota_client/api/struct.GetBalanceBuilder.html#method.with_initial_address_index"},(0,i.kt)("inlineCode",{parentName:"a"},".with_initial_address_index(initial_address_index: usize)")," "),"\nand\n",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/iota-client/latest/iota_client/api/struct.GetBalanceBuilder.html#method.with_gap_limit"},(0,i.kt)("inlineCode",{parentName:"a"},".with_gap_limit(gap_limit: usize)")),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Client.get_balance(seed)")," performs several tasks under the hood. It starts by generating addresses for the provided\n",(0,i.kt)("inlineCode",{parentName:"p"},"seed")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".account_index")," from ",(0,i.kt)("inlineCode",{parentName:"p"},".with_initial_address_index(account_index)"),", and checks for a balance of each of the\ngenerated addresses. Since it does not know how many addresses are used in fact, there is a condition set by the\n",(0,i.kt)("inlineCode",{parentName:"p"},".with_gap_limit(gap_limit)")," argument to know when to stop searching. If the ",(0,i.kt)("inlineCode",{parentName:"p"},".gap_limit")," amount of addresses in a row\nhave no balance, the function returns results and searching does not continue."),(0,i.kt)("h2",{id:"clientget_addressbalanceaddress-str"},(0,i.kt)("a",{parentName:"h2",href:"./../libraries/java/api_reference#balanceaddress-balanceaddressresponse"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.get_address().balance(address: &str)"))),(0,i.kt)("p",null,"You can use the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/iota-client/latest/iota_client/node/struct.GetAddressBuilder.html"},(0,i.kt)("inlineCode",{parentName:"a"},"GetAdressBuilder")),"\non a ",(0,i.kt)("inlineCode",{parentName:"p"},"Client")," instance and query for an addresses' balances by chaining a call to the ",(0,i.kt)("inlineCode",{parentName:"p"},"balance(address: String)"),"\nfunction."),(0,i.kt)("h2",{id:"clientget_addressoutputsaddress-str-options-outputoptions"},(0,i.kt)("a",{parentName:"h2",href:"./../libraries/java/api_reference#balanceaddress-balanceaddressresponse"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.get_address().outputs(address: &str, options: OutputOptions)"))),(0,i.kt)("p",null,"You can use the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.rs/iota-client/latest/iota_client/node/struct.GetAddressBuilder.html"},(0,i.kt)("inlineCode",{parentName:"a"},"GetAdressBuilder")),"\non a ",(0,i.kt)("inlineCode",{parentName:"p"},"Client")," instance and query for an addresses' balances by chaining a call to the ",(0,i.kt)("inlineCode",{parentName:"p"},"outputs(address: String)"),"\nfunction."),(0,i.kt)(p.Z,{className:"language-rust",mdxType:"CodeBlock"},'// Copyright 2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! cargo run --example 04_get_balance --release\n\nuse iota_client::{Client, Seed};\nextern crate dotenv;\nuse dotenv::dotenv;\nuse std::env;\n\n/// In this example we will get the account balance of a known seed and the balance and outputs of a known address\n\n#[tokio::main]\nasync fn main() {\n    // Create a client instance\n    let iota = Client::builder()\n        .with_node("https://api.lb-0.h.chrysalis-devnet.iota.cafe") // Insert your node URL here\n        .unwrap()\n        .with_node_sync_disabled()\n        .finish()\n        .await\n        .unwrap();\n\n    // This example uses dotenv, which is not safe for use in production\n    dotenv().ok();\n\n    let seed = Seed::from_bytes(&hex::decode(env::var("NONSECURE_USE_OF_DEVELOPMENT_SEED_1").unwrap()).unwrap());\n\n    let seed_balance = iota.get_balance(&seed).finish().await.unwrap();\n    println!("Account balance: {:?}i\\n", seed_balance);\n\n    let address = "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r";\n\n    let response = iota.get_address().balance(address).await.unwrap();\n    println!("The balance of {:?} is {:?}i\\n", address, response.balance);\n\n    let outputs = iota.get_address().outputs(address, Default::default()).await.unwrap();\n\n    println!("The outputs of address {:?} are: {:?}", address, outputs);\n}\n'),(0,i.kt)("p",null,"Example of output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'Account balance: 1096055332i\n\nThe balance of "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r" is 451055332i\n\nThe outputs of address "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r" are: [\n  UtxoInput(741673db85f78ebd95d04b572d1bf32e9207bbd265d90dbbe499a6d32f2b25470000),\n  UtxoInput(ed33089c623c67eb06dbc1c10b0c1c0424b0ace04a2e44070702668b3de440c80000),\n  UtxoInput(0af84c860dc461730064e7c4c88152ed8bea1ae72b1d6f5e4ab0c3e51ed185b70100),\n  ...]\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dustAllowed")," indicates whether the given address is allowed to accept a dust due to\n",(0,i.kt)("a",{parentName:"li",href:"https://wiki.iota.org/chrysalis-docs/faq#what-is-dust-protection-and-how-does-it-work"},"dust protection mechanism"),".")))}S.isMDXComponent=!0;var A=["components"],T={toc:[{value:"<code>Client.getAddressBalances(addresses: any)</code>",id:"clientgetaddressbalancesaddresses-any",level:2},{value:"<code>Client.getBalance(seed: string)</code>",id:"clientgetbalanceseed-string",level:2}]};function I(e){var n=e.components,t=(0,s.Z)(e,A);return(0,i.kt)("wrapper",(0,a.Z)({},T,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"There are two API calls you can use to get a balance:"),(0,i.kt)("h2",{id:"clientgetaddressbalancesaddresses-any"},(0,i.kt)("a",{parentName:"h2",href:"./../libraries/wasm/api_reference#Client+getAddressBalances"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.getAddressBalances(addresses: any)"))),(0,i.kt)("p",null," A convenient function that expects ",(0,i.kt)("inlineCode",{parentName:"p"},"list")," of addresses in Bech32 format and returns list of ",(0,i.kt)("inlineCode",{parentName:"p"},"dict")," with balances for all\ngiven addresses."),(0,i.kt)("h2",{id:"clientgetbalanceseed-string"},(0,i.kt)("a",{parentName:"h2",href:"./../libraries/wasm/api_reference#Client+getBalance"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.getBalance(seed: string)"))),(0,i.kt)("p",null," A convenient helper ",(0,i.kt)("a",{parentName:"p",href:"./../libraries/wasm/api_reference#BalanceGetter"},(0,i.kt)("inlineCode",{parentName:"a"},"BalanceGetter"))," class that combines\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/wasm/api_reference#Client+getAddresses"},(0,i.kt)("inlineCode",{parentName:"a"},"Client.getAddresses(seed: string)"))," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"Client.getAddressBalances()")," api calls. It returns a combined balance for the provided ",(0,i.kt)("inlineCode",{parentName:"p"},"seed")," and optional chaining\ncalls ",(0,i.kt)("a",{parentName:"p",href:"./../libraries/wasm/api_reference#BalanceGetter+accountIndex"},(0,i.kt)("inlineCode",{parentName:"a"},".accountIndex(index)")),",\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/wasm/api_reference#balancegetterinitialaddressindexinitial_address_index--codebalancegettercode"},(0,i.kt)("inlineCode",{parentName:"a"},".initialAddressIndex(initial_address_index: number)")),"\nand\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/wasm/api_reference#balancegettergap_limitgap_limit--codebalancegettercode"},(0,i.kt)("inlineCode",{parentName:"a"},".gap_limit(amount: number)"))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Client.getBalance(seed: string)")," performs several tasks under the hood. It starts by generating addresses for the\nprovided ",(0,i.kt)("inlineCode",{parentName:"p"},"seed")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".accountIndex")," from\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/wasm/api_reference#BalanceGetter+initialAddressIndex"},(0,i.kt)("inlineCode",{parentName:"a"},".initialAddressIndex(initial_address_index: number)")),",\nand checks for a balance of each of the generated addresses. Since it does not know how many addresses are used in fact,\nthere is a condition set by the\n",(0,i.kt)("a",{parentName:"p",href:"./../libraries/wasm/api_reference#BalanceGetter+gap_limit"},(0,i.kt)("inlineCode",{parentName:"a"},".gap_limit(amount: number)"))," argument to know when to stop\nsearching. If the ",(0,i.kt)("inlineCode",{parentName:"p"},".gap_limit")," amount of addresses in a row have no balance, the function returns results and searching\ndoes not continue."),(0,i.kt)(p.Z,{className:"language-javascript",mdxType:"CodeBlock"},'async function run() {\n    const { ClientBuilder } = require(\'../node\')\n\n    // Get the seed from environment variable\n    const IOTA_SEED_SECRET = process.env.IOTA_SEED_SECRET;\n\n    // client will connect to testnet by default\n    const client = await new ClientBuilder().build();\n\n    // Get the balance of a known address\n    console.log(\n        await client.getAddressBalances(["atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86"])\n    );\n\n    // Get the balance of addresses from an account\n    const balance = await client.getBalance(IOTA_SEED_SECRET)\n        .accountIndex(0)\n        .initialAddressIndex(0)\n        .get();\n\n    console.log("Account balance: " + balance);\n}\n\nrun()\n'),(0,i.kt)("p",null,"Example of output:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n   "address":"atoi1qp9427varyc05py79ajku89xarfgkj74tpel5egr9y7xu3wpfc4lkpx0l86",\n   "balance":10000000,\n   "dustAllowed":false,\n   "ledgerIndex": 2338924\n}\nAccount balance: 0\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"dustAllowed")," indicates whether the given address is allowed to accept a dust. You can learn more about dust\nprotection in the\n",(0,i.kt)("a",{parentName:"li",href:"https://wiki.iota.org/chrysalis-docs/faq#what-is-dust-protection-and-how-does-it-work"},"Chrysalis documentation"),".")))}I.isMDXComponent=!0;var B=["components"],O={title:"Check a Balance",description:"There are three common API calls you can use to get a balance using the Client, getAddressBalance, getAddressBalances and getBalance.",image:"/img/logo/iota_mark_light.png",keywords:["how to","account","address","nodejs","message","output","java","nodejs","python","rust","wasm"]},j=void 0,M={unversionedId:"examples/get_balance",id:"examples/get_balance",title:"Check a Balance",description:"There are three common API calls you can use to get a balance using the Client, getAddressBalance, getAddressBalances and getBalance.",source:"@site/content/build/iota.rs/production/documentation/docs/examples/get_balance.mdx",sourceDirName:"examples",slug:"/examples/get_balance",permalink:"/iota.rs/examples/get_balance",draft:!1,editUrl:"https://github.com/iotaledger/iota.rs/edit/production/documentation/content/build/iota.rs/production/documentation/docs/examples/get_balance.mdx",tags:[],version:"current",frontMatter:{title:"Check a Balance",description:"There are three common API calls you can use to get a balance using the Client, getAddressBalance, getAddressBalances and getBalance.",image:"/img/logo/iota_mark_light.png",keywords:["how to","account","address","nodejs","message","output","java","nodejs","python","rust","wasm"]},sidebar:"docs",previous:{title:"Generate Addresses",permalink:"/iota.rs/examples/generate_addresses"},next:{title:"Get Outputs",permalink:"/iota.rs/examples/get_outputs"}},D={},q=[],R={toc:q};function Z(e){var n=e.components,t=(0,s.Z)(e,B);return(0,i.kt)("wrapper",(0,a.Z)({},R,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)(c,{mdxType:"FaucetService"}),(0,i.kt)(r.Z,{groupId:"language",mdxType:"Tabs"},(0,i.kt)(d.Z,{value:"java",label:"Java",mdxType:"TabItem"},(0,i.kt)(k,{mdxType:"JavaGetBalance"})),(0,i.kt)(d.Z,{value:"nodejs",label:"Nodejs",mdxType:"TabItem"},(0,i.kt)(v,{mdxType:"NodejsGetBalance"})),(0,i.kt)(d.Z,{value:"python",label:"Python",mdxType:"TabItem"},(0,i.kt)(w,{mdxType:"PythonGetBalance"})),(0,i.kt)(d.Z,{value:"rust",label:"Rust",mdxType:"TabItem"},(0,i.kt)(S,{mdxType:"RustGetBalance"})),(0,i.kt)(d.Z,{value:"wasm",label:"Wasm",mdxType:"TabItem"},(0,i.kt)(I,{mdxType:"WasmGetBalance"}))))}Z.isMDXComponent=!0},18679:function(e,n,t){t.d(n,{Z:function(){return r}});var a=t(67294),s=t(86010),i="tabItem_Ymn6";function r(e){var n=e.children,t=e.hidden,r=e.className;return a.createElement("div",{role:"tabpanel",className:(0,s.Z)(i,r),hidden:t},n)}},34259:function(e,n,t){t.d(n,{Z:function(){return m}});var a=t(87462),s=t(67294),i=t(86010),r=t(51048),d=t(33609),l=t(1943),o=t(72957),c="tabList__CuJ",p="tabItem_LNqP";function u(e){var n,t,r=e.lazy,u=e.block,m=e.defaultValue,g=e.values,h=e.groupId,f=e.className,b=s.Children.map(e.children,(function(e){if((0,s.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),k=null!=g?g:b.map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes}})),_=(0,d.l)(k,(function(e,n){return e.value===n.value}));if(_.length>0)throw new Error('Docusaurus error: Duplicate values "'+_.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var C=null===m?m:null!=(n=null!=m?m:null==(t=b.find((function(e){return e.props.default})))?void 0:t.props.value)?n:b[0].props.value;if(null!==C&&!k.some((function(e){return e.value===C})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+C+'" but none of its children has the corresponding value. Available values are: '+k.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var v=(0,l.U)(),N=v.tabGroupChoices,y=v.setTabGroupChoices,w=(0,s.useState)(C),x=w[0],E=w[1],S=[],A=(0,o.o5)().blockElementScrollPositionUntilNextRender;if(null!=h){var T=N[h];null!=T&&T!==x&&k.some((function(e){return e.value===T}))&&E(T)}var I=function(e){var n=e.currentTarget,t=S.indexOf(n),a=k[t].value;a!==x&&(A(n),E(a),null!=h&&y(h,String(a)))},B=function(e){var n,t=null;switch(e.key){case"ArrowRight":var a,s=S.indexOf(e.currentTarget)+1;t=null!=(a=S[s])?a:S[0];break;case"ArrowLeft":var i,r=S.indexOf(e.currentTarget)-1;t=null!=(i=S[r])?i:S[S.length-1]}null==(n=t)||n.focus()};return s.createElement("div",{className:(0,i.Z)("tabs-container",c)},s.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":u},f)},k.map((function(e){var n=e.value,t=e.label,r=e.attributes;return s.createElement("li",(0,a.Z)({role:"tab",tabIndex:x===n?0:-1,"aria-selected":x===n,key:n,ref:function(e){return S.push(e)},onKeyDown:B,onFocus:I,onClick:I},r,{className:(0,i.Z)("tabs__item",p,null==r?void 0:r.className,{"tabs__item--active":x===n})}),null!=t?t:n)}))),r?(0,s.cloneElement)(b.filter((function(e){return e.props.value===x}))[0],{className:"margin-top--md"}):s.createElement("div",{className:"margin-top--md"},b.map((function(e,n){return(0,s.cloneElement)(e,{key:n,hidden:e.props.value!==x})}))))}function m(e){var n=(0,r.Z)();return s.createElement(u,(0,a.Z)({key:String(n)},e))}},94365:function(e,n){n.Z='package org.iota.client.example;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\n\nimport org.iota.client.*;\nimport org.iota.client.local.*;\n\npublic class ExampleApp {\n\n    protected static final String MAINNET = "https://chrysalis-nodes.iota.cafe";\n\n    // Faucet: https://faucet.chrysalis-devnet.iota.cafe/\n    // Explorer: https://explorer.iota.org/devnet\n    protected static final String TESTNET = "https://api.lb-0.h.chrysalis-devnet.iota.cafe";\n    protected static final String TESTNET_LB = "api.lb-0.h.chrysalis-devnet.iota.cafe";\n\n    protected static final String NODE = TESTNET;\n\n    static {\n        NativeAPI.verifyLink();\n    }\n\n    public static void main(String[] args) {\n\n        try {\n            new ExampleApp();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public ExampleApp() {\n\n    }\n\n    private static Client node() {\n        Client iota = Client.Builder().withNode(NODE) // Insert your node URL here\n                // .withNodeAuth("https://somechrysalisiotanode.com", "jwt_or_null",\n                // "name_or_null", "password_or_null") //\n                // Optional authentication\n                .finish();\n        return iota;\n    }\n\n    public static void nodeInfo() {\n        try {\n            Client iota = node();\n\n            System.out.println("Node healthy: " + iota.getHealth());\n\n            NodeInfoWrapper info = iota.getInfo();\n            System.out.println("Node url: " + info.url());\n            System.out.println("Node Info: " + info.nodeInfo());\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void generateSeed() {\n        try {\n            SecretKey secret_key = SecretKey.generate();\n            System.out.println(RustHex.encode(secret_key.toBytes()));\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void generateAddresses() {\n        try {\n            Client iota = node();\n\n            String seed = RustHex.encode("NONSECURE_USE_OF_DEVELOPMENT_SEED_1");\n            String[] addresses = GetAddressesBuilder.from(seed).withClient(iota).withRange(0, 10).finish();\n            System.out.println(Arrays.toString(addresses));\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void getBalance() {\n        try {\n            Client iota = node();\n\n            String seed = "NONSECURE_USE_OF_DEVELOPMENT_SEED_1";\n\n            long seed_balance = iota.getBalance(seed).finish();\n            System.out.println("Account balance: " + seed_balance);\n\n            String address = "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r";\n\n            BalanceAddressResponse response = iota.getAddress().balance(address);\n            System.out.println("The balance of " + address + " is " + response.balance());\n\n            UtxoInput[] outputs = iota.getAddress().outputs(address, new OutputsOptions());\n            System.out.println("The outputs of address " + address + " are: " + Arrays.toString(outputs));\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void getOutputs() {\n        try {\n            Client iota = node();\n\n            String address = "atoi1qzt0nhsf38nh6rs4p6zs5knqp6psgha9wsv74uajqgjmwc75ugupx3y7x0r";\n\n            UtxoInput[] outputs = iota.getAddress().outputs(address, new OutputsOptions());\n            System.out.println("The outputs of address " + address + " are: " + Arrays.toString(outputs));\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void simpleMessage() {\n        try {\n            Client iota = node();\n            Message message = iota.message().finish();\n\n            System.out.println(\n                    "Empty message sent: https://explorer.iota.org/mainnet/message/" + message.id().toString());\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void getMessageMetadata() {\n        try {\n            Client iota = node();\n            Message message = iota.message().finish();\n\n            MessageMetadata metadata = iota.getMessage().metadata(message.id());\n\n            System.out.println("Message metadata: " + metadata);\n        } catch (ClientException e) {\n            System.out.println("Error: " + e.getMessage());\n        }\n    }\n\n    public static void getDataMessage() {\n        Client iota = node();\n\n        Message message = iota.message().withIndexString("Hello").withDataString("Tangle").finish();\n\n        System.out.println("Message sent https://explorer.iota.org/devnet/message/" + message.id());\n\n        MessageId[] fetched_message_ids = iota.getMessage().indexString("Hello");\n        System.out.println("Messages with Hello index: " + Arrays.toString(fetched_message_ids));\n    }\n\n    public static void transaction() {\n        Client iota = node();\n\n        String seed_1 = "NONSECURE_USE_OF_DEVELOPMENT_SEED_1";\n\n        Message message = iota\n            .message()\n            .withSeed(seed_1)\n            // Insert the output address and amount to spent. The amount cannot be zero.\n            .withOutput(\n                // We generate an address from our seed so that we send the funds to ourselves\n                        iota.getAddresses(seed_1).withRange(0, 1).finish()[0], 1000000\n            ).finish();\n\n        System.out.println("Transaction sent: https://explorer.iota.org/devnet/message/" +  message.id());\n    }\n\n    public static void mqtt() {\n        Client iota = node();\n\n        MqttListener listener = new MqttListener() {\n            @Override\n            public void onEvent(TopicEvent event) {\n                System.out.println(event);\n            }\n        };\n\n        // TODO: Make listeners with the Sync trait\n        // iota.subscriber().withTopic(Topic.from("messages")).subscribe(listener);\n    }\n\n    public static void consolidate() {\n        Client iota = node();\n\n        String seed = "NONSECURE_USE_OF_DEVELOPMENT_SEED_1";\n\n        // Here all funds will be send to the address with the lowest index in the range\n        String address = Util.consolidateFunds(iota, seed, 0, 0, 150);\n\n        System.out.println("Funds consolidated to" + address);\n    }\n\n    public static void createMaxDust(){\n        Client iota = node();\n        String seed = "NONSECURE_USE_OF_DEVELOPMENT_SEED_1";\n        String seed_2 = "NONSECURE_USE_OF_DEVELOPMENT_SEED_2";\n\n        String[] new_addresses = iota.getAddresses(seed_2).withRange(0, 1).finish();\n\n        Message dustAllowanceMessage = iota\n            .message()\n            .withSeed(seed)\n            .withDustAllowanceOutput(new_addresses[0], 10_000_000)\n            .finish();\n\n        MessageWrap[] msgs = iota.retryUntilIncluded(dustAllowanceMessage.id(), -1, -1);\n\n        // Split funds to own addresses\n        String[] addresses = iota\n            .getAddresses(seed)\n            // We start from index 1 so we can send remaining balance to the address with index 0\n            .withRange(1, 101)\n            .finish();\n\n        ClientMessageBuilder message_builder = iota.message().withSeed(seed);\n        for (String address : addresses) {\n            // Make sure to re-set the builder as the instance is a clone of the old one due to JNI limits\n            message_builder = message_builder.withOutput(address, 1_000_001);\n        }\n        Message message = message_builder.finish();\n\n        System.out.println(\n            "First transaction sent: https://explorer.iota.org/devnet/message/" + message.id()\n        );\n\n        msgs = iota.retryUntilIncluded(message.id(), -1, -1);\n\n        // At this point we have 100 Mi on 100 addresses and we will just send it to the final address\n        // We use the outputs directly so we don\'t double spend them\n        \n        List<UtxoInput> initial_outputs = new ArrayList<>();\n        Optional<MessagePayload> payload = message.payload();\n        if (payload.isPresent() && payload.get().payloadType().equals(MessagePayloadType.TRANSACTION)) {\n            TransactionPayload tx = payload.get().asTransaction();\n            RegularEssence essence = tx.essence().asRegular();\n            Output[] outputs = essence.outputs();\n            for (int index = 0; index < outputs.length; index++) {\n                Output output = outputs[index];\n                if (output.asSignatureLockedSingleOutput().amount() == 1_000_001) {\n                    initial_outputs.add(UtxoInput.from(tx.id(), index));\n                } \n            }\n        }\n\n        String[] first_address_old_seed = iota.getAddresses(seed).withRange(0, 1).finish();\n        List<MessageId> sent_messages = new ArrayList<>();\n        for (UtxoInput input : initial_outputs) {\n            MessageId message_id = iota\n                .message()\n                    .withSeed(seed).withInput(input).withInputRange(1, 101).withOutput(new_addresses[0], 1)\n                // send remaining iotas back\n                    .withOutput(first_address_old_seed[0], 1_000_000)\n                .finish()\n                    .id();\n            System.out.printf("Transaction %i sent: https://explorer.iota.org/devnet/message/%s" + input.index(),\n                    message_id\n            );\n            sent_messages.add(message_id);\n        }\n        // only check last message, if this gets confirmed all other messages should also be confirmed\n        msgs = iota.retryUntilIncluded(sent_messages.get(sent_messages.size() - 1), -1, -1);\n        // Send all funds back to first address\n        long total_balance = iota.getBalance(seed).finish();\n\n        System.out.println("Total balance: " + total_balance);\n\n        message = iota\n            .message()\n            .withSeed(seed)\n            .withOutput(first_address_old_seed[0], total_balance)\n            .finish();\n\n        System.out.println("Final tx sent: https://explorer.iota.org/devnet/message/" + message.id());\n\n        msgs = iota.retryUntilIncluded(message.id(), -1, -1);\n    }\n\n    public static void customPayload() {\n        // Create a client instance\n        Client iota = node();\n\n        IndexationPayload indexation_payload = IndexationPayload.fromStrings("Your Index", "Your Data");\n\n        Message message = iota.message().finishIndex(indexation_payload);\n\n        System.out.printf("Message ID: %s", message.id());\n    }\n\n    public static void offlineExample() {\n        String seed = "NONSECURE_USE_OF_DEVELOPMENT_SEED_1";\n        String toAddress = "atoi1qruzprxum2934lr3p77t96pzlecxv8pjzvtjrzdcgh2f5exa22n6gek0qdq";\n        long amount = 1_000_000;\n\n        Offline offlineExample = new Offline(NODE, seed);\n        String[] inputAddresses = offlineExample.generateAddresses();\n        String preparedData = offlineExample.prepareTransaction(inputAddresses, toAddress, amount);\n        System.out.println("Prepared data: " + preparedData);\n        String signedData = offlineExample.signTransaction(preparedData);\n        System.out.println("Signed data: " + signedData);\n\n        Message message = offlineExample.sendMessage(signedData);\n\n        System.out.printf("Message ID: %s", message.id());\n    }\n}\n'}}]);