"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[30958],{10223:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>m,frontMatter:()=>i,metadata:()=>c,toc:()=>p});var r=t(87462),s=(t(67294),t(3905)),o=t(44393),a=t(43791);const i={title:"How To Generate Addresses"},d=void 0,c={unversionedId:"libraries/nodejs/how_to/generate_addresses",id:"libraries/nodejs/how_to/generate_addresses",title:"How To Generate Addresses",description:"",source:"@site/content/build/iota.rs/develop/documentation/docs/libraries/nodejs/how_to/4_generate_addresses.mdx",sourceDirName:"libraries/nodejs/how_to",slug:"/libraries/nodejs/how_to/generate_addresses",permalink:"/iota.rs/develop/libraries/nodejs/how_to/generate_addresses",draft:!1,editUrl:"https://github.com/iotaledger/iota.rs/edit/develop/documentation/content/build/iota.rs/develop/documentation/docs/libraries/nodejs/how_to/4_generate_addresses.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"How To Generate Addresses"},sidebar:"docs",previous:{title:"How To Generate A Mnemonic",permalink:"/iota.rs/develop/libraries/nodejs/how_to/generate_mnemonic"},next:{title:"How To Create A Block",permalink:"/iota.rs/develop/libraries/nodejs/how_to/create_block"}},l={},p=[],u={toc:p};function m(e){let{components:n,...t}=e;return(0,s.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)(o.Z,{className:"language-typescript",mdxType:"CodeBlock"},"// Copyright 2021-2022 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\nimport {\n    Client,\n    CoinType,\n    initLogger,\n    SHIMMER_TESTNET_BECH32_HRP,\n} from '@iota/client';\nrequire('dotenv').config({ path: '../.env' });\n\n// Run with command:\n// node ./dist/02_generate_addresses.js\n\n// In this example we will create addresses from a mnemonic defined in .env\nasync function run() {\n    initLogger();\n    if (!process.env.NODE_URL) {\n        throw new Error('.env NODE_URL is undefined, see .env.example');\n    }\n\n    const client = new Client({\n        // Insert your node URL in the .env.\n        nodes: [process.env.NODE_URL],\n    });\n\n    try {\n        if (!process.env.NON_SECURE_USE_OF_DEVELOPMENT_MNEMONIC_1) {\n            throw new Error('.env mnemonic is undefined, see .env.example');\n        }\n        const secretManager = {\n            Mnemonic: process.env.NON_SECURE_USE_OF_DEVELOPMENT_MNEMONIC_1,\n        };\n\n        // Generate public address with custom account index and range.\n        const address = await client.generateAddresses(secretManager, {\n            accountIndex: 0,\n            range: {\n                start: 0,\n                end: 1,\n            },\n        });\n        console.log('First public address:', address, '\\n');\n\n        // Generate an internal address with custom account index and range.\n        const internalAddress = await client.generateAddresses(secretManager, {\n            accountIndex: 0,\n            range: {\n                start: 0,\n                end: 1,\n            },\n            internal: true,\n        });\n        console.log('First internal address:', internalAddress, '\\n');\n\n        // Generate addresses with providing all inputs, that way it can also be done offline without a node.\n        const offlineGeneratedAddresses = await client.generateAddresses(\n            secretManager,\n            {\n                coinType: CoinType.Shimmer,\n                accountIndex: 0,\n                range: {\n                    start: 0,\n                    end: 2,\n                },\n                internal: false,\n                // Generating addresses with client.generateAddresses(secretManager, {}), will by default get the bech32_hrp (Bech32\n                // human readable part) from the node info, generating it \"offline\" requires setting it in the generateAddressesOptions\n                bech32Hrp: SHIMMER_TESTNET_BECH32_HRP,\n            },\n        );\n        console.log(\n            'List of offline generated public addresses:',\n            offlineGeneratedAddresses,\n        );\n    } catch (error) {\n        console.error('Error: ', error);\n    }\n}\n\nrun().then(() => process.exit());\n"),(0,s.kt)(a.ZP,{mdxType:"MoreExamples"}))}m.isMDXComponent=!0},43791:(e,n,t)=>{t.d(n,{ZP:()=>a});var r=t(87462),s=(t(67294),t(3905));const o={toc:[]};function a(e){let{components:n,...t}=e;return(0,s.kt)("wrapper",(0,r.Z)({},o,t,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"More advanced examples can be found in the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/iotaledger/iota.rs/tree/develop/bindings/nodejs/examples"},"examples")," folder."))}a.isMDXComponent=!0}}]);