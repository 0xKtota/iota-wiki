"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[98904],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>m});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function c(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):c(c({},n),e)),t},l=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),p=u(t),m=r,f=p["".concat(s,".").concat(m)]||p[m]||d[m]||o;return t?a.createElement(f,c(c({ref:n},l),{},{components:t})):a.createElement(f,c({ref:n},l))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,c=new Array(o);c[0]=p;var i={};for(var s in n)hasOwnProperty.call(n,s)&&(i[s]=n[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,c[1]=i;for(var u=2;u<o;u++)c[u]=t[u];return a.createElement.apply(null,c)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},1929:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>u,toc:()=>d});var a=t(87462),r=(t(67294),t(3905)),o=t(54411),c=t(43305);const i={keywords:["functions","thunk","insert operations"],description:"Thunk functions encapsulate access and parameter checking and set up the type-safe function-specific contexts. Thunks are used to insert operations at the beginning or end of the other function to adapt it to changing requirements",image:"/img/logo/WASP_logo_dark.png"},s="Thunk Functions",u={unversionedId:"guide/schema/thunks",id:"guide/schema/thunks",title:"Thunk Functions",description:"Thunk functions encapsulate access and parameter checking and set up the type-safe function-specific contexts. Thunks are used to insert operations at the beginning or end of the other function to adapt it to changing requirements",source:"@site/content/build/wasp/production/documentation/docs/guide/schema/thunks.mdx",sourceDirName:"guide/schema",slug:"/guide/schema/thunks",permalink:"/smart-contracts/guide/schema/thunks",draft:!1,editUrl:"https://github.com/iotaledger/wasp/edit/master/documentation/content/build/wasp/production/documentation/docs/guide/schema/thunks.mdx",tags:[],version:"current",frontMatter:{keywords:["functions","thunk","insert operations"],description:"Thunk functions encapsulate access and parameter checking and set up the type-safe function-specific contexts. Thunks are used to insert operations at the beginning or end of the other function to adapt it to changing requirements",image:"/img/logo/WASP_logo_dark.png"},sidebar:"tutorialSidebar",previous:{title:"Function Results",permalink:"/smart-contracts/guide/schema/results"},next:{title:"View-Only Functions",permalink:"/smart-contracts/guide/schema/views"}},l={},d=[],p={toc:d};function m(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"thunk-functions"},"Thunk Functions"),(0,r.kt)("p",null,"In computer programming, a thunk is a function used to inject a calculation into another\nfunction. Thunks are used to insert operations at the beginning or end of the other\nfunction to adapt it to changing requirements. If you remember from\nthe ",(0,r.kt)("a",{parentName:"p",href:"/smart-contracts/guide/wasm_vm/context"},"function call context")," section, the ",(0,r.kt)("inlineCode",{parentName:"p"},"on_load")," function and\nskeleton function signatures looked like this:"),(0,r.kt)(o.Z,{defaultValue:"go",groupId:"language",values:[{label:"Go",value:"go"},{label:"Rust",value:"rust"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},(0,r.kt)(c.Z,{value:"go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'func OnLoad() {\n    exports := wasmlib.NewScExports()\n    exports.AddFunc("divide", funcDivide)\n    exports.AddFunc("init", funcInit)\n    exports.AddFunc("member", funcMember)\n    exports.AddFunc("setOwner", funcSetOwner)\n    exports.AddView("getFactor", viewGetFactor)\n    exports.AddView("getOwner", viewGetOwner)\n}\n\nfunc funcDivide(ctx wasmlib.ScFuncContext) {}\nfunc funcInit(ctx wasmlib.ScFuncContext) {}\nfunc funcMember(ctx wasmlib.ScFuncContext) {}\nfunc funcSetOwner(ctx wasmlib.ScFuncContext) {}\nfunc viewGetFactor(ctx wasmlib.ScViewContext) {}\nfunc viewGetOwner(ctx wasmlib.ScViewContext) {}\n'))),(0,r.kt)(c.Z,{value:"rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'fn on_load() {\n    let exports = ScExports::new();\n    exports.add_func("divide", func_divide);\n    exports.add_func("init", func_init);\n    exports.add_func("member", func_member);\n    exports.add_func("setOwner", func_set_owner);\n    exports.add_view("getFactor", view_get_factor);\n    exports.add_view("getOwner", view_get_owner);\n}\n\nfn func_divide(ctx: &ScFuncContext) {}\nfn func_init(ctx: &ScFuncContext) {}\nfn func_member(ctx: &ScFuncContext) {}\nfn func_set_owner(ctx: &ScFuncContext) {}\nfn view_get_factor(ctx: &ScViewContext) {}\nfn view_get_owner(ctx: &ScViewContext) {}\n'))),(0,r.kt)(c.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'export function on_load() {\n    let exports = new ScExports();\n    exports.addFunc("divide", funcDivide);\n    exports.addFunc("init", funcInit);\n    exports.addFunc("member", funcMember);\n    exports.addFunc("setOwner", funcSetOwner);\n    exports.addView("getFactor", viewGetFactor);\n    exports.addView("getOwner", viewGetOwner);\n}\n\nfunction funcDivide(ctx: ScFuncContext) {}\nfunction funcInit(ctx: ScFuncContext) {}\nfunction funcMember(ctx: ScFuncContext) {}\nfunction funcSetOwner(ctx: ScFuncContext) {}\nfunction viewGetFactor(ctx: ScViewContext) {}\nfunction viewGetOwner(ctx: ScViewContext) {}\n')))),(0,r.kt)("p",null,"Now that the schema tool introduces a bunch of automatically generated features, that is\nno longer sufficient. Luckily, the schema tool also generates thunks to inject these\nfeatures, before calling the function implementations that are maintained by the user.\nHere is the new ",(0,r.kt)("inlineCode",{parentName:"p"},"on_load")," function for the ",(0,r.kt)("inlineCode",{parentName:"p"},"dividend")," contract:"),(0,r.kt)(o.Z,{defaultValue:"go",groupId:"language",values:[{label:"Go",value:"go"},{label:"Rust",value:"rust"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},(0,r.kt)(c.Z,{value:"go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"func OnLoad() {\n    exports := wasmlib.NewScExports()\n    exports.AddFunc(FuncDivide, funcDivideThunk)\n    exports.AddFunc(FuncInit, funcInitThunk)\n    exports.AddFunc(FuncMember, funcMemberThunk)\n    exports.AddFunc(FuncSetOwner, funcSetOwnerThunk)\n    exports.AddView(ViewGetFactor, viewGetFactorThunk)\n    exports.AddView(ViewGetOwner, viewGetOwnerThunk)\n\n    for i, key := range keyMap {\n        idxMap[i] = key.KeyID()\n    }\n}\n"))),(0,r.kt)(c.Z,{value:"rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"fn on_load() {\n    let exports = ScExports::new();\n    exports.add_func(FUNC_DIVIDE, func_divide_thunk);\n    exports.add_func(FUNC_INIT, func_init_thunk);\n    exports.add_func(FUNC_MEMBER, func_member_thunk);\n    exports.add_func(FUNC_SET_OWNER, func_set_owner_thunk);\n    exports.add_view(VIEW_GET_FACTOR, view_get_factor_thunk);\n    exports.add_view(VIEW_GET_OWNER, view_get_owner_thunk);\n\n    unsafe {\n        for i in 0..KEY_MAP_LEN {\n            IDX_MAP[i] = get_key_id_from_string(KEY_MAP[i]);\n        }\n    }\n}\n"))),(0,r.kt)(c.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"export function on_load(): void {\n    let exports = new wasmlib.ScExports();\n    exports.addFunc(sc.FuncDivide, funcDivideThunk);\n    exports.addFunc(sc.FuncInit, funcInitThunk);\n    exports.addFunc(sc.FuncMember, funcMemberThunk);\n    exports.addFunc(sc.FuncSetOwner, funcSetOwnerThunk);\n    exports.addView(sc.ViewGetFactor, viewGetFactorThunk);\n    exports.addView(sc.ViewGetOwner, viewGetOwnerThunk);\n\n    for (let i = 0; i < sc.keyMap.length; i++) {\n        sc.idxMap[i] = wasmlib.Key32.fromString(sc.keyMap[i]);\n    }\n}\n")))),(0,r.kt)("p",null,"As you can see, instead of calling the user functions directly, we now call thunk versions\nof these functions. We also added initialization of a local array that holds all key IDs\nnegotiated with the host, so that we can simply use (generated) indexes into this array\ninstead of having to negotiate these IDs each time we need them. The rest of the generated\ncode will use those indexes whenever a known key is used."),(0,r.kt)("p",null,"Here is an example of a thunk function for the ",(0,r.kt)("inlineCode",{parentName:"p"},"setOwner")," contract function. You can\nexamine the other thunks that all follow the same pattern in the generated ",(0,r.kt)("inlineCode",{parentName:"p"},"lib.xx"),":"),(0,r.kt)(o.Z,{defaultValue:"go",groupId:"language",values:[{label:"Go",value:"go"},{label:"Rust",value:"rust"},{label:"TypeScript",value:"ts"}],mdxType:"Tabs"},(0,r.kt)(c.Z,{value:"go",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'type SetOwnerContext struct {\n    Params ImmutableSetOwnerParams\n    State  MutableDividendState\n}\n\nfunc funcSetOwnerThunk(ctx wasmlib.ScFuncContext) {\n    ctx.Log("dividend.funcSetOwner")\n    // only defined owner of contract can change owner\n    access := ctx.State().GetAgentID(wasmlib.Key("owner"))\n    ctx.Require(access.Exists(), "access not set: owner")\n    ctx.Require(ctx.Caller() == access.Value(), "no permission")\n\n    f := &SetOwnerContext{\n        Params: ImmutableSetOwnerParams{\n            id: wasmlib.OBJ_ID_PARAMS,\n        },\n        State: MutableDividendState{\n            id: wasmlib.OBJ_ID_STATE,\n        },\n    }\n    ctx.Require(f.Params.Owner().Exists(), "missing mandatory owner")\n    funcSetOwner(ctx, f)\n    ctx.Log("dividend.funcSetOwner ok")\n}\n'))),(0,r.kt)(c.Z,{value:"rust",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'pub struct SetOwnerContext {\n    params: ImmutableSetOwnerParams,\n    state:  MutableDividendState,\n}\n\nfn func_set_owner_thunk(ctx: &ScFuncContext) {\n    ctx.log("dividend.funcSetOwner");\n    // only defined owner of contract can change owner\n    let access = ctx.state().get_agent_id("owner");\n    ctx.require(access.exists(), "access not set: owner");\n    ctx.require(ctx.caller() == access.value(), "no permission");\n\n    let f = SetOwnerContext {\n        params: ImmutableSetOwnerParams {\n            id: OBJ_ID_PARAMS,\n        },\n        state: MutableDividendState {\n            id: OBJ_ID_STATE,\n        },\n    };\n    ctx.require(f.params.owner().exists(), "missing mandatory owner");\n    func_set_owner(ctx, &f);\n    ctx.log("dividend.funcSetOwner ok");\n}\n'))),(0,r.kt)(c.Z,{value:"ts",mdxType:"TabItem"},(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'export class SetOwnerContext {\n    params: sc.ImmutableSetOwnerParams = new sc.ImmutableSetOwnerParams();\n    state: sc.MutableDividendState = new sc.MutableDividendState();\n}\n\nfunction funcSetOwnerThunk(ctx: wasmlib.ScFuncContext): void {\n    ctx.log("dividend.funcSetOwner");\n    // only defined owner of contract can change owner\n    let access = ctx.state().getAgentID(wasmlib.Key32.fromString("owner"));\n    ctx.require(access.exists(), "access not set: owner");\n    ctx.require(ctx.caller().equals(access.value()), "no permission");\n\n    let f = new sc.SetOwnerContext();\n    f.params.mapID = wasmlib.OBJ_ID_PARAMS;\n    f.state.mapID = wasmlib.OBJ_ID_STATE;\n    ctx.require(f.params.owner().exists(), "missing mandatory owner")\n    sc.funcSetOwner(ctx, f);\n    ctx.log("dividend.funcSetOwner ok");\n}\n')))),(0,r.kt)("p",null,"First, the thunk logs the contract and function name to show the call has started. Then it\nsets up the access control for the function according to the schema definition file.\nIn this case it retrieves the ",(0,r.kt)("inlineCode",{parentName:"p"},"owner")," state variable, requires that it exists, and then\nrequires that the caller() of the function equals that value. Any failing requirement will\npanic out of the function with an error message. So this code makes sure only the owner of\nthe contract can call this function."),(0,r.kt)("p",null,"Next, we set up a strongly typed function-specific context structure. First, we add the\nfunction-specific immutable ",(0,r.kt)("inlineCode",{parentName:"p"},"params")," interface structure, which is only present when the\nfunction can have parameters. Then we add the contract-specific ",(0,r.kt)("inlineCode",{parentName:"p"},"state")," interface\nstructure. In this case it is mutable because setOwner is a ",(0,r.kt)("a",{parentName:"p",href:"/smart-contracts/guide/schema/funcs"},"Func"),". For\n",(0,r.kt)("a",{parentName:"p",href:"/smart-contracts/guide/schema/views"},"Views")," this will be an immutable state interface. Finally, we add the\nfunction-specific mutable ",(0,r.kt)("inlineCode",{parentName:"p"},"results")," interface structure, which is only present when the\nfunction returns results. Obviously, this is not the case for this setOwner function."),(0,r.kt)("p",null,"Now we get to the point where we can use the function-specific ",(0,r.kt)("inlineCode",{parentName:"p"},"params")," interface to check\nfor mandatory parameters. Each mandatory parameter is required to exist, or else we will\npanic out of the function with an error message."),(0,r.kt)("p",null,"With the automated checks and setup completed, we now call the function implementation\nthat is maintained by the user. After the user function has completed, we log that the\ncontract function has completed successfully. Remember that any error within the user\nfunction will cause a panic, so this logging will never happen in that case."),(0,r.kt)("p",null,"In the next section we will look at the specifics of ",(0,r.kt)("a",{parentName:"p",href:"/smart-contracts/guide/schema/views"},"view functions"),"."))}m.isMDXComponent=!0},43305:(e,n,t)=>{t.d(n,{Z:()=>c});var a=t(67294),r=t(86010);const o="tabItem__kUE";function c(e){let{children:n,hidden:t,className:c}=e;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(o,c),hidden:t},n)}},54411:(e,n,t)=>{t.d(n,{Z:()=>m});var a=t(87462),r=t(67294),o=t(86010),c=t(51048),i=t(33609),s=t(1943),u=t(72957);const l="tabList_fbd4",d="tabItem_v5XY";function p(e){var n,t;const{lazy:c,block:p,defaultValue:m,values:f,groupId:h,className:w}=e,g=r.Children.map(e.children,(e=>{if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),x=null!=f?f:g.map((e=>{let{props:{value:n,label:t,attributes:a}}=e;return{value:n,label:t,attributes:a}})),b=(0,i.l)(x,((e,n)=>e.value===n.value));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const k=null===m?m:null!=(n=null!=m?m:null==(t=g.find((e=>e.props.default)))?void 0:t.props.value)?n:g[0].props.value;if(null!==k&&!x.some((e=>e.value===k)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+k+'" but none of its children has the corresponding value. Available values are: '+x.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:v,setTabGroupChoices:y}=(0,s.U)(),[_,O]=(0,r.useState)(k),S=[],{blockElementScrollPositionUntilNextRender:T}=(0,u.o5)();if(null!=h){const e=v[h];null!=e&&e!==_&&x.some((n=>n.value===e))&&O(e)}const F=e=>{const n=e.currentTarget,t=S.indexOf(n),a=x[t].value;a!==_&&(T(n),O(a),null!=h&&y(h,String(a)))},I=e=>{var n;let t=null;switch(e.key){case"ArrowRight":{var a;const n=S.indexOf(e.currentTarget)+1;t=null!=(a=S[n])?a:S[0];break}case"ArrowLeft":{var r;const n=S.indexOf(e.currentTarget)-1;t=null!=(r=S[n])?r:S[S.length-1];break}}null==(n=t)||n.focus()};return r.createElement("div",{className:(0,o.Z)("tabs-container",l)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":p},w)},x.map((e=>{let{value:n,label:t,attributes:c}=e;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:_===n?0:-1,"aria-selected":_===n,key:n,ref:e=>S.push(e),onKeyDown:I,onFocus:F,onClick:F},c,{className:(0,o.Z)("tabs__item",d,null==c?void 0:c.className,{"tabs__item--active":_===n})}),null!=t?t:n)}))),c?(0,r.cloneElement)(g.filter((e=>e.props.value===_))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},g.map(((e,n)=>(0,r.cloneElement)(e,{key:n,hidden:e.props.value!==_})))))}function m(e){const n=(0,c.Z)();return r.createElement(p,(0,a.Z)({key:String(n)},e))}}}]);