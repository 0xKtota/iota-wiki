"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[46949],{3905:function(e,a,t){t.d(a,{Zo:function(){return p},kt:function(){return h}});var n=t(67294);function i(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function s(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function l(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?s(Object(t),!0).forEach((function(a){i(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function o(e,a){if(null==e)return{};var t,n,i=function(e,a){if(null==e)return{};var t,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||(i[t]=e[t]);return i}(e,a);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)t=s[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var r=n.createContext({}),m=function(e){var a=n.useContext(r),t=a;return e&&(t="function"==typeof e?e(a):l(l({},a),e)),t},p=function(e){var a=m(e.components);return n.createElement(r.Provider,{value:a},e.children)},c={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},d=n.forwardRef((function(e,a){var t=e.components,i=e.mdxType,s=e.originalType,r=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=m(t),h=i,u=d["".concat(r,".").concat(h)]||d[h]||c[h]||s;return t?n.createElement(u,l(l({ref:a},p),{},{components:t})):n.createElement(u,l({ref:a},p))}));function h(e,a){var t=arguments,i=a&&a.mdxType;if("string"==typeof e||i){var s=t.length,l=new Array(s);l[0]=d;var o={};for(var r in a)hasOwnProperty.call(a,r)&&(o[r]=a[r]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var m=2;m<s;m++)l[m]=t[m];return n.createElement.apply(null,l)}return n.createElement.apply(null,t)}d.displayName="MDXCreateElement"},12652:function(e,a,t){t.r(a),t.d(a,{assets:function(){return p},contentTitle:function(){return r},default:function(){return h},frontMatter:function(){return o},metadata:function(){return m},toc:function(){return c}});var n=t(87462),i=t(63366),s=(t(67294),t(3905)),l=["components"],o={description:"This section introduces  *access Mana* and *consensus Mana* and explains which modules use which Mana.",image:"https://raw.githubusercontent.com/iotaledger/IOTA-2.0-Research-Specifications/section/mana/images/cmana.png",slug:"5.3Mana",keywords:["consensus","node","access mana","transactions","base mana","consensus mana","reference time"]},r="5.3 Mana",m={unversionedId:"5.3 Mana",id:"5.3 Mana",title:"5.3 Mana",description:"This section introduces  *access Mana* and *consensus Mana* and explains which modules use which Mana.",source:"@site/content/build/iota-2.0-research-specifications/5.3 Mana.md",sourceDirName:".",slug:"/5.3Mana",permalink:"/IOTA-2.0-Research-Specifications/5.3Mana",draft:!1,editUrl:"https://github.com/iotaledger/IOTA-2.0-Research-Specifications/edit/main/docusaurus/content/build/iota-2.0-research-specifications/5.3 Mana.md",tags:[],version:"current",frontMatter:{description:"This section introduces  *access Mana* and *consensus Mana* and explains which modules use which Mana.",image:"https://raw.githubusercontent.com/iotaledger/IOTA-2.0-Research-Specifications/section/mana/images/cmana.png",slug:"5.3Mana",keywords:["consensus","node","access mana","transactions","base mana","consensus mana","reference time"]},sidebar:"tutorialSidebar",previous:{title:"5.2 Ledger State",permalink:"/IOTA-2.0-Research-Specifications/5.2LedgerState"},next:{title:"6.1 Objects of Consensus",permalink:"/IOTA-2.0-Research-Specifications/6.1ObjectsOfConsensus"}},p={},c=[{value:"5.3.1 Introduction",id:"531-introduction",level:2},{value:"5.3.2. Detailed Design - General",id:"532-detailed-design---general",level:2},{value:"5.3.3 Detailed Design - Consensus Mana",id:"533-detailed-design---consensus-mana",level:2},{value:"5.3.3.1 Consensus Mana Update Procedure",id:"5331-consensus-mana-update-procedure",level:3},{value:"Pledging the cMana relative to a transaction with timestamp smaller than the last reference time",id:"pledging-the-cmana-relative-to-a-transaction-with-timestamp-smaller-than-the-last-reference-time",level:4},{value:"Pledging the cMana relative to a transaction with timestamp larger than the last reference time",id:"pledging-the-cmana-relative-to-a-transaction-with-timestamp-larger-than-the-last-reference-time",level:4},{value:"Updating the cMana to a time larger than the last reference time without any new cMana pledging",id:"updating-the-cmana-to-a-time-larger-than-the-last-reference-time-without-any-new-cmana-pledging",level:4},{value:"5.3.3.2 Active Consensus Mana and Epochs",id:"5332-active-consensus-mana-and-epochs",level:3},{value:"5.3.4 Detailed Design - Access Mana",id:"534-detailed-design---access-mana",level:2},{value:"5.3.4.1 Access Mana Update Procedure",id:"5341-access-mana-update-procedure",level:3},{value:"Pledging the aMana relative to a transaction with timestamp smaller than the last reference time",id:"pledging-the-amana-relative-to-a-transaction-with-timestamp-smaller-than-the-last-reference-time",level:4},{value:"Pledging the aMana relative to a transaction with timestamp larger than the last reference time",id:"pledging-the-amana-relative-to-a-transaction-with-timestamp-larger-than-the-last-reference-time",level:4},{value:"Updating the aMana to a time larger than the last reference time without any new aMana pledging.",id:"updating-the-amana-to-a-time-larger-than-the-last-reference-time-without-any-new-amana-pledging",level:4},{value:"5.3.5. Initialization",id:"535-initialization",level:2},{value:"5.3.6. Algorithm",id:"536-algorithm",level:2},{value:"5.3.6.1. Parameter Values",id:"5361-parameter-values",level:3},{value:"5.3.6.2. Local Variables and Built-in Functions",id:"5362-local-variables-and-built-in-functions",level:3},{value:"5.3.6.3. Pseudocode - cMana Update",id:"5363-pseudocode---cmana-update",level:2},{value:"<code>UpdateBasecManaTr(transaction)</code>",id:"updatebasecmanatrtransaction",level:4},{value:"<code>UpdatecManaTime(epoch)</code>",id:"updatecmanatimeepoch",level:4},{value:"<code>UpdatecManaTr(epoch,transaction)</code>",id:"updatecmanatrepochtransaction",level:4},{value:"<code>UpdatecMana(epoch)</code>",id:"updatecmanaepoch",level:4},{value:"5.3.6.4. Pseudocode - aMana Update",id:"5364-pseudocode---amana-update",level:3},{value:"<code>UpdateBaseaManaTime(t)</code>",id:"updatebaseamanatimet",level:4},{value:"<code>UpdateaManaTime(t)</code>",id:"updateamanatimet",level:4},{value:"<code>UpdateBaseaManaTr(transaction)</code>",id:"updatebaseamanatrtransaction",level:4},{value:"<code>UpdateaManaTr(transaction)</code>",id:"updateamanatrtransaction",level:4},{value:"<code>UpdateaMana(transaction)</code>",id:"updateamanatransaction",level:4}],d={toc:c};function h(e){var a=e.components,t=(0,i.Z)(e,l);return(0,s.kt)("wrapper",(0,n.Z)({},d,t,{components:a,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"53-mana"},"5.3 Mana"),(0,s.kt)("h2",{id:"531-introduction"},"5.3.1 Introduction"),(0,s.kt)("p",null,"This section introduces  ",(0,s.kt)("em",{parentName:"p"},"access Mana")," and ",(0,s.kt)("em",{parentName:"p"},"consensus Mana")," and determines which modules use each of these two types of Mana."),(0,s.kt)("p",null,"Any permissionless system needs a Sybil protection mechanism. In Coordicide, this is done by forcing every node to create a node identity (see also ",(0,s.kt)("a",{parentName:"p",href:"./3.3PeerDiscovery"},"Section 3.3 - Peer Discovery"),"). Since the creation of an arbitrarily large number of identities is not an expensive operation, two ",(0,s.kt)("em",{parentName:"p"},"Difficult-to-obtain")," resources are linked to each node identity; we call them ",(0,s.kt)("em",{parentName:"p"},"access Mana"),"(",(0,s.kt)("strong",{parentName:"p"},"aMana"),") and ",(0,s.kt)("em",{parentName:"p"},"consensus Mana")," (",(0,s.kt)("strong",{parentName:"p"},"cMana"),"). Both kinds of Mana can be described as essential resources to multiple parts of the network. They are related to the IOTA token, but are not tokens by themselves "," and do not interfere with the token balance in any direct way. When a transaction is processed, a certain amount of aMana and cMana\u2014dependent on the amount of IOTAs moved by the transaction\u2014will be pledged to nodes specified in the transaction (their node IDs must be specified as defined in ",(0,s.kt)("a",{parentName:"p",href:"./2.2MessageLayout"},"Section 2.2 - Standard Payloads Layout"),"). The access and consensus Mana pledged to each node ID must be stored as an extension of the ledger state. The only way a node can obtain aMana or cMana is to convince some ken holders to pledge to it. Both kinds of Mana provides adequate Sybil protection because they are difficult and costly to be acquired in arbitrarily large amounts.  "),(0,s.kt)("p",null,"Access and consensus Mana are used as Sybil protection in different modules, which have different natures and requirements. For this reason, it is natural to use different formulas to calculate the appropriate Mana to each module. Consensus Mana should be seen as the Mana that is responsible for the security of the system, on the other hand, access Mana is used to distribute access to the network during congestion periods."),(0,s.kt)("p",null,"We give a short overview on how each module uses its associated kind of Mana:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"./3.4NeighborSelection"},"Section 3.4 - Neighbor Selection"),":  Nodes only establish a connection with nodes of similar consensus Mana."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"./4.6CongestionControl"},"Section 4.6 - Congestion Control"),": The throughput (in bytes per second) of each node is dependent on the access Mana held."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"./6.3FastProbabilisticConsensus"},"Section 6.3 -  Fast Probabilistic Consensus"),": The selection probability for a node during a voting query is proportional to the consensus Mana held."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"./6.4Finalization"},"Section 6.4 - Finalization"),": Finalization occurs when (among other criteria) a message is approved by nodes holding a certain fraction of the consensus Mana in the network.")),(0,s.kt)("p",null,"The Mana specification depends on the following specification:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"./4.2Timestamps"},"4.2 - Timestamps"))),(0,s.kt)("h2",{id:"532-detailed-design---general"},"5.3.2. Detailed Design - General"),(0,s.kt)("p",null,"Each transaction must have an ",(0,s.kt)("inlineCode",{parentName:"p"},"accessManaNodeID")," and a ",(0,s.kt)("inlineCode",{parentName:"p"},"consensusManaNodeID")," field to determine which node to pledge these two types of Mana. Both of these fields consist of a node ID of the node that will receive each kind of Mana. Access Mana and consensus Mana do not have to be pledged to the same node."),(0,s.kt)("p",null,"Both kinds of Mana are ",(0,s.kt)("em",{parentName:"p"},"exponential moving averages")," (EMA) of the ",(0,s.kt)("em",{parentName:"p"},"base Manas")," (specifically, cMana is the EMA of base cMana, and aMana is the EMA of base aMana). An EMA is a type of moving average that places a greater weight and significance on the most recent data points. More precisely, the weighting for older data decreases exponentially in time, however, never reaching zero.  "," "),(0,s.kt)("p",null,"Even though the definition of an EMA should be unique (no matter to which function that you apply it), the general algorithm for the calculation of the EMAs\u2014with the flexibility needed in our case\u2014is not easily implementable. Thus, two different algorithms already customized for each type of Mana are provided in the present document."),(0,s.kt)("p",null,"We define the following parameters:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"\\gamma"),"- decay factor for base aMana."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"\\alpha"),"- moving average factor for the cMana. "),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"\\beta"),"- moving average factor for the aMana. ")),(0,s.kt)("p",null,"Additionally, we define four vectors that assign a real value to each node Id: the ",(0,s.kt)("em",{parentName:"p"},"aMana vector"),", ",(0,s.kt)("em",{parentName:"p"},"base aMana vector"),", ",(0,s.kt)("em",{parentName:"p"},"cMana vector")," and base ",(0,s.kt)("em",{parentName:"p"},"cMana vector"),". The base aMana vector and the base cMana vector are auxiliary vectors (meaning that they are needed to compute the aMana vector and the cMana vector, even though their values are not directly used in any of the modules). Due to the time dependance of the EMA (and also the base aMana function), the four vectors have a ",(0,s.kt)("em",{parentName:"p"},"reference time")," to which they are associated."),(0,s.kt)("p",null,"The Mana vectors are updated in different occasions. Access Mana pledging happens when a transaction is booked on the ledger state. At the same time, entries of the nodes whose aMana is not being modified during the pledging are updated only with respect to the (possibly) newer time reference. In general, updates only due to time (without aMana pledging) happen whenever a node's aMana is being accessed by an external module (as the congestion control, for instance). "),(0,s.kt)("p",null,"On the other hand, cMana is updated only relatively to the end of each epoch (see ",(0,s.kt)("a",{parentName:"p",href:"./4.2Timestamps"},"Section 4.2 - Timestamps"),"). The reason behind this is that epochs are objective, i.e. all nodes agree on which epoch a certain message (or transaction) belongs to. Thus, since nodes agree (with high probability) about transactions with timestamps older than the end of the epoch plus ",(0,s.kt)("inlineCode",{parentName:"p"},"TIMESTAMP_CUTOFF")," (see ",(0,s.kt)("a",{parentName:"p",href:"./4.2Timestamps"},"Section 4.2 - Timestamps"),"), they will consequently agree\u2014again, with high probability\u2013about the cMana vector relative to these transactions. "),(0,s.kt)("p",null,"Therefore, one can assume that the nodes in sync will (with high probability) agree on values of cMana relative to the set of transactions that have timestamp older than a fixed epoch in the past. On the other hand, aMana will capture recent fluctuations, but nodes are expected to have slightly different perceptions of this quantity."),(0,s.kt)("h2",{id:"533-detailed-design---consensus-mana"},"5.3.3 Detailed Design - Consensus Mana"),(0,s.kt)("p",null,"The base cMana of a node ",(0,s.kt)("inlineCode",{parentName:"p"},"nodeID")," at time ",(0,s.kt)("inlineCode",{parentName:"p"},"time")," is defined as the sum over all unspent outputs at time ",(0,s.kt)("inlineCode",{parentName:"p"},"time")," of transactions  with  ",(0,s.kt)("inlineCode",{parentName:"p"},"consensusManaNodeID = nodeID"),". This means that, when an output is consumed, its cMana pledge is revoked and pledged to a (possibly) different node. See the example below: "),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Example 1:")),(0,s.kt)("p",null,"Suppose transaction ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"z")," was booked and we want to update the base cMana vector accordingly. Additionally, suppose transaction ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"z"),", ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"x")," and ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"y")," pledges cMana to nodes ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"N_z"),",  ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"N_x")," and ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"N_y"),", respectively."),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://raw.githubusercontent.com/iotaledger/IOTA-2.0-Research-Specifications/section/mana/images/cmana.png"},(0,s.kt)("img",{parentName:"a",src:"https://raw.githubusercontent.com/iotaledger/IOTA-2.0-Research-Specifications/section/mana/images/cmana.png",alt:"CMana"}))),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Image 5.3.1:")," Illustration of outputs being consumed."),(0,s.kt)("p",null,"The update of the base cMana proceeds as follows: "),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"Add 300 to the base cMana state of the node ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"N_z"),"."),(0,s.kt)("li",{parentName:"ol"},"Subtract 100 from the base cMana state of the node ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"N_x"),"."),(0,s.kt)("li",{parentName:"ol"},"Subtract 200 from the base cMana state of the node ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"N_y"),".")),(0,s.kt)("p",null,"If a transaction ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"T_i")," with timestamp ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t_i")," pledges ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"M_i")," cMana to a node ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"Z"),", then the cMana evolution over time relative to this transaction will be given by:"),(0,s.kt)("div",{className:"math math-display"},"\\text{cMana}_Z^{T_i}(t) = \\begin{cases}\n        0, \\text{ if } t< t_i \\\\\n        M_i\\left(1-e^{-\\alpha (t-t_i)}\\right), \\text{ if } t\\geq t_i  \\\\\n\\end{cases}"),(0,s.kt)("p",null,"The total cMana of a node ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"Z")," will be, then, given by the sum of ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\text{cMana}_Z^{T_i}(t)")," among all the transactions ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"T_i")," that pledge cMana to node ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"Z"),". Nevertheless, computing the mana using this equation may be excessively demanding in the case where a node has multiples pledges at different times. For that reason, the cMana shall be computed recursively, updating it based on its last value. This update is customized for three different situations (here, ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t_0")," is the reference time of the previous cMana value):"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"pledging of the cMana relative to a transaction with timestamp smaller than ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"t_0"),".  "),(0,s.kt)("li",{parentName:"ol"},"pledging of the cMana relative to a transaction with timestamp larger than ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"t_0"),".  "),(0,s.kt)("li",{parentName:"ol"},"updating the cMana to a time ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"t_1>t_0")," without any new cMana pledging.")),(0,s.kt)("p",null,"In the first case, the reference time of the cMana must not be changed, whereas in the second case, the reference time of the cMana must be changed to the timestamp of the transaction. This means that a node must never update the cMana to a point in the past (relatively to the last cMana calculated). The exact update procedure for each of the cases defined above are defined next."),(0,s.kt)("h3",{id:"5331-consensus-mana-update-procedure"},"5.3.3.1 Consensus Mana Update Procedure"),(0,s.kt)("h4",{id:"pledging-the-cmana-relative-to-a-transaction-with-timestamp-smaller-than-the-last-reference-time"},"Pledging the cMana relative to a transaction with timestamp smaller than the last reference time"),(0,s.kt)("p",null,"Suppose that the last reference time is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t")," and the transaction timestamp is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t-s"),". The update must be done in two steps, always in the order specified below:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("em",{parentName:"p"},"a"),") ",(0,s.kt)("strong",{parentName:"p"},"Base cMana update"),". Just before updating the base cMana vector we must store it, since the last base cMana state (that we call ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\text{Old\\_Base\\_cMana}"),") and the time relative to the last update are used later for the cMana calculations. This temporary vector can be deleted right after the cMana vector is updated."),(0,s.kt)("p",{parentName:"li"},"  The update of the base cMana state goes as follows: if a new transaction with ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"n")," inputs of values ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"x_1, x_2, \\ldots, x_n")," pledges cMana to a node ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"N"),", then"),(0,s.kt)("ol",{parentName:"li"},(0,s.kt)("li",{parentName:"ol"},"we add ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"\\sum_{j=1}^{n}x_j")," to the base cMana of the node ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"N"),"."),(0,s.kt)("li",{parentName:"ol"},"Each input ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"I_j")," corresponds to some UTXO (and, consequently, to some transaction) stored in the ledger state. Then, we locate the node Id (let us say, ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"\\text{Node}_j"),") to whom the cMana relative to this output was pledged to in the past. Then, we subtract ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"x_j")," from the base cMana state of the node ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"\\text{Node}_j"),", for each ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"I_j"),", ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"j=1,\\dots,n"),"."))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("em",{parentName:"p"},"b"),") ",(0,s.kt)("strong",{parentName:"p"},"Pledging and revoking cMana"),". If the base cMana balance of node ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"i")," (before we added this transaction) was ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\text{Old\\_Base\\_cMana}(\\text{Node}_i)")," and the new base cMana balance (after the addition of this transaction) is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\text{Base\\_cMana}(\\text{Node}_i)"),", then we update the cMana vector adding to all nodes' entry the term:"),(0,s.kt)("div",{parentName:"li",className:"math math-display"},"(1-e^{-\\alpha s})[\\text{Base\\_cMana}(\\text{Node}_i)-\\text{Old\\_Base\\_cMana}(\\text{Node}_i)]"),(0,s.kt)("p",{parentName:"li"},"  The term above can be negative\u2014since some nodes have their base cMana revoked\u2014but the resulting cMana must not be. Notice that for most nodes (specifically, for all nodes that did not have their base cMana value changed) the value above is zero."))),(0,s.kt)("h4",{id:"pledging-the-cmana-relative-to-a-transaction-with-timestamp-larger-than-the-last-reference-time"},"Pledging the cMana relative to a transaction with timestamp larger than the last reference time"),(0,s.kt)("p",null,"Suppose that the last reference time is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t-s")," and the transaction timestamp is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t"),". The update must be done in two steps, always in the order specified below:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("em",{parentName:"p"},"a"),") ",(0,s.kt)("strong",{parentName:"p"},"Base cMana update"),". Just before updating the base cMana vector we must store it, since the last base cMana state (that we call ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\text{Old\\_Base\\_cMana}"),") and the time relative to the last update are used later for the cMana calculations. This temporary vector can be deleted right after the cMana vector is updated."),(0,s.kt)("p",{parentName:"li"},"  The update of the base cMana state goes as follows: if a new transaction with ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"n")," inputs of respective values ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"x_1, x_2, \\ldots, x_n")," pledges cMana to a node ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"N"),", then"),(0,s.kt)("ol",{parentName:"li"},(0,s.kt)("li",{parentName:"ol"},"we add ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"\\sum_{j=1}^{n}x_j")," to the base cMana of the node ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"N"),"."),(0,s.kt)("li",{parentName:"ol"},"Each input ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"I_j")," corresponds to some UTXO (and, consequently, to some transaction) stored in the ledger state. Then, we locate the node Id (let us say, ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"\\text{Node}_j"),") to whom the cMana relative to this output was pledged to in the past. Then, we subtract ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"x_j")," from the base cMana state of the node ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"\\text{Node}_j"),", for each ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"I_j"),", ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"j=1,\\dots,n"),"."))),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("em",{parentName:"p"},"b"),") ",(0,s.kt)("strong",{parentName:"p"},"Updating the cMana with respect to time"),". Suppose that the outdated cMana is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\text{Old\\_cMana}"),". We update all cMana entries as follows:"),(0,s.kt)("div",{parentName:"li",className:"math math-display"},"\\text{cMana}(\\text{Node}_i)=e^{-\\alpha s} \\text{Old\\_cMana}(\\text{Node}_i)+(1-e^{-\\alpha s})\\text{Old\\_Base\\_cMana}(\\text{Node}_i)"),(0,s.kt)("p",{parentName:"li"},"  where ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\alpha")," is the moving average parameter for the cMana.\n"))),(0,s.kt)("h4",{id:"updating-the-cmana-to-a-time-larger-than-the-last-reference-time-without-any-new-cmana-pledging"},"Updating the cMana to a time larger than the last reference time without any new cMana pledging"),(0,s.kt)("p",null,"Suppose that the last reference time is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t-s"),", the new one is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t")," and the last cMana vector is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\text{Old\\_cMana}"),". We update all cMana entries as follows:"),(0,s.kt)("div",{className:"math math-display"},"    \\text{cMana}(\\text{Node}_i)=e^{-\\alpha s} \\text{Old\\_cMana}(\\text{Node}_i)+(1-e^{-\\alpha s})\\text{Old\\_Base\\_cMana}(\\text{Node}_i)"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre"},"where $\\alpha$ is the moving average parameter for the cMana. \n")),(0,s.kt)("h3",{id:"5332-active-consensus-mana-and-epochs"},"5.3.3.2 Active Consensus Mana and Epochs"),(0,s.kt)("p",null,"The consensus Mana of a node is only calculated and stored relatively to the end of each epoch (see ",(0,s.kt)("a",{parentName:"p",href:"./4.2Timestamps"},"Section 4.2 - Timestamps"),"). Only the values of the last ",(0,s.kt)("inlineCode",{parentName:"p"},"MAX_STORED_EPOCHS")," epochs are stored. Thus, if ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t_E")," is the time of the end of epoch ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"E"),", to update the cMana vector from epoch ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"E-1")," to ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"E"),", a node must perform the following algorithm:"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"Update the cMana with respect to time, as described in section 4.3.3.1.3, from time ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t_{E-1}")," to ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t_{E}"))),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"For each transaction with timestamp in the interval ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"[t_{E-1},t_{E})"),", perform (as described in section 4.3.3.1.1) the base cMana update and the pledge and revoking of cMana, while the reference time ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t_{E}")," remains constant."))),(0,s.kt)("p",null,"Additionally, we define the ",(0,s.kt)("em",{parentName:"p"},"active consensus Mana")," of a node A in epoch E (i.e., relatively to time ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t_{E}"),") as (here, ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\text{cMana}")," is also relative to time ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t_{E}"),"):"),(0,s.kt)("div",{className:"math math-display"},"\\text{Active\\_cMana}(\\text{node A})=\\begin{cases}\n\\text{cMana}(\\text{node A}), \\text{ if at least one message from node A with timestamp is in }[t_{E-1},t_{E}) \\\\\n0, \\text{ otherwise}\n\\end{cases}"),(0,s.kt)("p",null,"Therefore, even if node ",(0,s.kt)("inlineCode",{parentName:"p"},"node")," has consensus Mana greater than zero at a certain epoch ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"E"),", it can be considered dormant in case it did not issue any message during the same epoch. All nodes that have active consensus Mana in epoch ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"E")," will form what we call the active consensus Mana set of that epoch, or ",(0,s.kt)("inlineCode",{parentName:"p"},"ACMS(E)"),"."),(0,s.kt)("p",null,"Both calculations defined above (cMana and active cMana on an epoch ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"E"),") can only be carried out when epoch ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"E")," is finalized\u2014that is, at least ",(0,s.kt)("inlineCode",{parentName:"p"},"TIMESTAMP_CUTOFF")," (see ",(0,s.kt)("a",{parentName:"p",href:"./4.2Timestamps"},"Section 4.2 - Timestamps"),") units of time after ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t_E"),"\u2014to make sure that no more messages belonging to the epoch will appear in the network."),(0,s.kt)("p",null,"The following data structures and functions must be defined:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"UpdatecMana(epoch)"),": updates the base cMana and cMana vectors from the end of ",(0,s.kt)("inlineCode",{parentName:"p"},"epoch-1")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"epoch"),", pledging and revoking the base cMana and cMana relative to all the relevant transactions. ")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"GetActiveConsensusMana(time)"),": returns a mapping between all known nodes and their active cMana, calculated at the end of the epoch that contains ",(0,s.kt)("inlineCode",{parentName:"p"},"time"),".")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"ManaRank(lowerMana, upperMana, epoch)"),": returns the node ID of the nodes with active cMana in the interval ",(0,s.kt)("inlineCode",{parentName:"p"},"[lowerMana, upperMana]"),", relative to ",(0,s.kt)("inlineCode",{parentName:"p"},"epoch"),". Notice that ",(0,s.kt)("inlineCode",{parentName:"p"},"epoch")," must be, at least, the current epoch minus ",(0,s.kt)("inlineCode",{parentName:"p"},"MAX_STORED_EPOCHS")," and, at most, the last epoch."))),(0,s.kt)("h2",{id:"534-detailed-design---access-mana"},"5.3.4 Detailed Design - Access Mana"),(0,s.kt)("p",null,"When an output is consumed and funds are consequently transferred, a certain amount of base aMana\u2014dependent on the amount of funds and the age of the output\u2014will be pledged to a node. This pledge is never revoked, as opposed to base cMana. Nevertheless, the base aMana of all nodes will ",(0,s.kt)("em",{parentName:"p"},"decay")," over time, which means that all the calculations for aMana will be slightly different than for cMana. The base aMana at time ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t"),", relative to an output ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"T_i")," (of amount ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"M_i"),") consumed by a transaction with timestamp ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t-s")," and generated by a transaction with timestamp ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t-s-\\delta")," is, for ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"s,\\delta>0")),(0,s.kt)("div",{className:"math math-display"},"  \\text{Base\\_aMana}^{T_i}(t)= M (1-e^{-\\gamma \\delta}) e^{-\\gamma s}, \\text{ if } t\\geq t-s"),(0,s.kt)("p",null,"If this same output pledges aMana to a node ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"Z"),", then the aMana evolution over time (again, for ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"s,\\delta>0"),") relative to it will be given by:"),(0,s.kt)("div",{className:"math math-display"},"\\text{aMana}_Z^{T_i}(t) = \\begin{cases}\n        M_i(1-e^{-\\gamma\\delta})\\dfrac{\\beta e^{-\\beta s}}{\\beta-\\gamma}\\left(e^{(\\beta-\\gamma)s}-1\\right), \\text{ if }\\beta\\neq \\gamma\\\\\n        M_i(1-e^{-\\gamma\\delta})\\gamma s e^{-\\gamma s}, \\text{ if } \\beta= \\gamma\\\\\n\\end{cases}"),(0,s.kt)("p",null,"The base aMana of a node ",(0,s.kt)("inlineCode",{parentName:"p"},"nodeID")," at time ",(0,s.kt)("inlineCode",{parentName:"p"},"time")," is defined as the sum of the individual base aMana generated by all already consumed outputs ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"T_i")," of transactions  with  ",(0,s.kt)("inlineCode",{parentName:"p"},"accessManaNodeID = nodeID")," and timestamp smaller or equal than ",(0,s.kt)("inlineCode",{parentName:"p"},"time"),". Nevertheless, as in the cMana case, computing the aMana using this equation can be excessively demanding. For that reason, the aMana shall computed recursively, updating it based on its last value. This update is customized for three different situations (here, ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t_0")," is the reference time of the last aMana value):"),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},"pledging of the aMana relative to a transaction with timestamp smaller than ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"t_0"),";"),(0,s.kt)("li",{parentName:"ol"},"pledging of the aMana relative to a transaction with timestamp larger than ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"t_0"),";"),(0,s.kt)("li",{parentName:"ol"},"updating the aMana to a time ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},"t_1>t_0")," without any new aMana pledging.")),(0,s.kt)("p",null,"In the first case, the reference time of the aMana must not be changed, whereas in the second case, the reference time of the cMana must be changed to the timestamp of the transaction. This means that a node must never update the aMana to a point in the past (relatively to the last aMana calculated). The exact update procedure for each of the cases defined above are defined next."),(0,s.kt)("h3",{id:"5341-access-mana-update-procedure"},"5.3.4.1 Access Mana Update Procedure"),(0,s.kt)("h4",{id:"pledging-the-amana-relative-to-a-transaction-with-timestamp-smaller-than-the-last-reference-time"},"Pledging the aMana relative to a transaction with timestamp smaller than the last reference time"),(0,s.kt)("p",null,"Suppose that the last reference time is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t")," and the transaction timestamp is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t-s"),". The update must be done in two steps, always in the order specified below:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Base aMana pledging"),". Suppose that the new transaction consists of ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"m")," inputs ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"I_1, I_2, \\ldots, I_m")," of value ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"x_1, x_2, \\ldots, x_m"),"\u2014respectively\u2014and pledges aMana to a node ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"N"),". We update the base aMana of node ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"N")," by adding to its base aMana the value"),(0,s.kt)("div",{parentName:"li",className:"math math-display"},"d=e^{-\\gamma s} \\sum_{j=1}^{m}x_j(1-e^{-\\gamma \\delta_{j}})"),(0,s.kt)("p",{parentName:"li"},"  where ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\delta_{j}>0")," is the difference between ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t")," and the timestamps of the transaction that generated ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"I_j")," and ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\gamma")," is the decay factor. This value ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"d")," has to be temporarily stored, since it will be used in the aMana update.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Pledging aMana"),". We update the aMana vector adding to node ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"N"),"'s entry the term:"),(0,s.kt)("div",{parentName:"li",className:"math math-display"},"\\begin{cases}  \n\\frac{e^{-\\gamma s}-e^{-\\beta s}}{(\\beta-\\gamma)e^{-\\gamma s}}\\beta d,\\text{ if }\\beta\\neq\\gamma;\\\\\ns \\beta d,\\text{ if }\\beta=\\gamma,\\\\\n\\end{cases}"),(0,s.kt)("p",{parentName:"li"},"  where the term ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"d")," is the same it was added when updating the base aMana vector. "))),(0,s.kt)("h4",{id:"pledging-the-amana-relative-to-a-transaction-with-timestamp-larger-than-the-last-reference-time"},"Pledging the aMana relative to a transaction with timestamp larger than the last reference time"),(0,s.kt)("p",null,"Suppose that the last reference time is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t-s")," and the transaction timestamp is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t"),". The update must be done in three steps, always in the order specified below:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Base aMana update with respect to time"),". Suppose that the last base aMana is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\text{Old\\_Base\\_aMana}"),". We update all base aMana entries as follows:"),(0,s.kt)("div",{parentName:"li",className:"math math-display"},"\\text{Base\\_aMana}(\\text{Node}_i) = e^{-\\gamma s}\\text{Old\\_Base\\_aMana}(\\text{Node}_i)")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Base aMana pledging"),". Suppose that the new transaction consists of ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"m")," inputs ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"I_1, I_2, \\ldots, I_m")," of value ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"x_1, x_2, \\ldots, x_m"),", respectively, and pledges aMana to a node ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"N"),". We update the base aMana of node ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"N")," by adding to its base aMana the value"),(0,s.kt)("div",{parentName:"li",className:"math math-display"},"d=\\sum_{j=1}^{m}x_j(1-e^{-\\gamma \\delta_{j}})"),(0,s.kt)("p",{parentName:"li"},"  where ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\delta_{j}>0")," is the difference between ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t")," and the timestamps of the transaction that generated ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"I_j")," and ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\gamma")," is the decay factor. This value ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"d")," has to be temporarily stored, since it will be used in the aMana update.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Updating the aMana with respect to time"),".  We update all aMana entries as follows:"),(0,s.kt)("div",{parentName:"li",className:"math math-display"},"\\text{ aMana}(\\text{Node}_i)=\\begin{cases}  \ne^{-\\beta s} \\text{Old\\_aMana}(\\text{Node}_i)+\\frac{e^{-\\gamma s}-e^{-\\beta s}}{(\\beta-\\gamma)e^{-\\gamma s}}    \\beta\\text{Base\\_aMana}(\\text{Node}_i),\\text{ if }\\beta\\neq\\gamma;\\\\\ne^{-\\beta s} \\text{Old\\_aMana}(\\text{Node}_i)+s\\beta\\text{Base\\_aMana}(\\text{Node}_i),\\text{ if }\\beta=\\gamma,\\\\\n\\end{cases}"),(0,s.kt)("p",{parentName:"li"},"  where ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\beta")," is the moving average parameter for the aMana and ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\gamma")," is the base aMana decay factor. Notice that, here, the value of ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\text{Base\\_aMana(Node}_i)")," used is the one already updated. "))),(0,s.kt)("h4",{id:"updating-the-amana-to-a-time-larger-than-the-last-reference-time-without-any-new-amana-pledging"},"Updating the aMana to a time larger than the last reference time without any new aMana pledging."),(0,s.kt)("p",null,"Suppose that the last reference time is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t-s")," and new one is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"t"),". The update must be done in two steps, always in the order specified below:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Base aMana update with respect to time"),". Suppose that the outdated base aMana is ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\text{Old\\_Base\\_aMana}"),". We update the base aMana entries as follows:"),(0,s.kt)("div",{parentName:"li",className:"math math-display"},"\\text{Base\\_aMana}(\\text{Node}_i) = e^{-\\gamma s}\\text{Old\\_Base\\_aMana}(\\text{Node}_i)")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("strong",{parentName:"p"},"Updating the aMana with respect to time"),". We update all the aMana entries as follows:"),(0,s.kt)("div",{parentName:"li",className:"math math-display"},"\\text{aMana}(\\text{Node}_i)=\\begin{cases}  \ne^{-\\beta s} \\text{Old\\_aMana}(\\text{Node}_i)+\\frac{e^{-\\gamma s}-e^{-\\beta s}}{(\\beta-\\gamma)e^{-\\gamma s}}    \\beta\\text{Base\\_aMana}(\\text{Node}_i),\\text{ if }\\beta\\neq\\gamma;\\\\\ne^{-\\beta s} \\text{Old\\_aMana}(\\text{Node}_i)+s\\beta\\text{Base\\_aMana}(\\text{Node}_i),\\text{ if }\\beta=\\gamma,\\\\\n\\end{cases}"),(0,s.kt)("p",{parentName:"li"},"  where ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\beta")," is the moving average parameter for the aMana and ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\gamma")," is the base aMana decay factor. Notice that, here, the value of ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},"\\text{Base\\_aMana(Node}_i)")," used is the one already updated. "))),(0,s.kt)("p",null,"The following data structures and functions must be defined:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"GetAccessMana()"),": returns a mapping between all known nodes and their access Mana, calculated at ",(0,s.kt)("inlineCode",{parentName:"p"},"currentTime")," (which means that the aMana is updated to ",(0,s.kt)("inlineCode",{parentName:"p"},"currentTime")," when this function is called).")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},(0,s.kt)("inlineCode",{parentName:"p"},"UpdateaMana(transaction)"),": whenever a transaction ",(0,s.kt)("inlineCode",{parentName:"p"},"transaction")," is added to the ledger state, it updates the aMana vector in order to add the aMana relative to ",(0,s.kt)("inlineCode",{parentName:"p"},"transaction")," and to the (possibly) new reference time."))),(0,s.kt)("h2",{id:"535-initialization"},"5.3.5. Initialization"),(0,s.kt)("p",null,"The Mana is an extension of the ledger state, hence its calculation depends on the ledger state perception of the node. Snapshotting is the mechanism that stores older ledger states and prunes unnecessary messages. Together with the ledger state, aMana and cMana vectors (and the reference time relative to them) are also saved, since a certain ledger state reflects a certain aMana and cMana distribution in the network. Thus, when a node joins the network, it will query other nodes to get their snapshot file, containing a ",(0,s.kt)("inlineCode",{parentName:"p"},"aMana Snapshot Vector"),", a ",(0,s.kt)("inlineCode",{parentName:"p"},"cMana Snapshot Vector"),", and two ",(0,s.kt)("inlineCode",{parentName:"p"},"ACMS")," (one for each of the last two snapshotted epochs) that will be used as initialization data. "),(0,s.kt)("h2",{id:"536-algorithm"},"5.3.6. Algorithm"),(0,s.kt)("h3",{id:"5361-parameter-values"},"5.3.6.1. Parameter Values"),(0,s.kt)("p",null,"The following parameters will be used by default, and all nodes must know them. We do not have explicit rules to punish nodes that clearly do not use these parameters, but we expect that they would be eventually ignored, due to other implicit mechanisms. For instance, even if the Mana vectors of a certain node are significantly different from the other nodes' view (causing a divergence from the majority's opinion in the voting protocol), with a very high probability its opinion will not affect the final outcome of the voting. For other modules (like congestion control), a node with a significantly different perception of Mana will be blacklisted and will not harm the network. Thus, the nodes have plenty of incentives to follow the rules."),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Name"),(0,s.kt)("th",{parentName:"tr",align:"center"},"Type"),(0,s.kt)("th",{parentName:"tr",align:null},"Description"),(0,s.kt)("th",{parentName:"tr",align:null},"Observation"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"DECAY")),(0,s.kt)("td",{parentName:"tr",align:"center"},"float"),(0,s.kt)("td",{parentName:"tr",align:null},"decay factor for base aMana"),(0,s.kt)("td",{parentName:"tr",align:null},"Called ",(0,s.kt)("span",{parentName:"td",className:"math math-inline"},"\\gamma")," in the last sections. For a half life of ~6 hours we need ",(0,s.kt)("span",{parentName:"td",className:"math math-inline"},"\\gamma=0.00192541 \\frac{1}{\\text{min}}"),".")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"C_MANA_EMA_COEFF")),(0,s.kt)("td",{parentName:"tr",align:"center"},"float"),(0,s.kt)("td",{parentName:"tr",align:null},"moving average factor for the cMana"),(0,s.kt)("td",{parentName:"tr",align:null},"Called ",(0,s.kt)("span",{parentName:"td",className:"math math-inline"},"\\alpha")," in the last sections. Set as the same value as ",(0,s.kt)("span",{parentName:"td",className:"math math-inline"},"\\gamma"),".")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"A_MANA_EMA_COEFF")),(0,s.kt)("td",{parentName:"tr",align:"center"},"float"),(0,s.kt)("td",{parentName:"tr",align:null},"moving average factor for the aMana"),(0,s.kt)("td",{parentName:"tr",align:null},"Called ",(0,s.kt)("span",{parentName:"td",className:"math math-inline"},"\\beta")," in the last sections. Set as the same value as ",(0,s.kt)("span",{parentName:"td",className:"math math-inline"},"\\gamma"),".")))),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Table 5.3.2:")," List of Parameters."),(0,s.kt)("h3",{id:"5362-local-variables-and-built-in-functions"},"5.3.6.2. Local Variables and Built-in Functions"),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:null},"Name"),(0,s.kt)("th",{parentName:"tr",align:"center"},"Type"),(0,s.kt)("th",{parentName:"tr",align:null},"Description"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"object.cManaNode")),(0,s.kt)("td",{parentName:"tr",align:"center"},"nodeID"),(0,s.kt)("td",{parentName:"tr",align:null},"Id of the node to which ",(0,s.kt)("inlineCode",{parentName:"td"},"object"),"'s cMana was pledged")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"object.amount")),(0,s.kt)("td",{parentName:"tr",align:"center"},"double"),(0,s.kt)("td",{parentName:"tr",align:null},"Amount moved by ",(0,s.kt)("inlineCode",{parentName:"td"},"object"))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"object.aManaNode")),(0,s.kt)("td",{parentName:"tr",align:"center"},"nodeID"),(0,s.kt)("td",{parentName:"tr",align:null},"Id of the node to which ",(0,s.kt)("inlineCode",{parentName:"td"},"object"),"'s aMana was pledged")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"transaction.inputs")),(0,s.kt)("td",{parentName:"tr",align:"center"},"list of inputs IDs"),(0,s.kt)("td",{parentName:"tr",align:null},"List of inputs consumed by ",(0,s.kt)("inlineCode",{parentName:"td"},"transaction"))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"transaction.time")),(0,s.kt)("td",{parentName:"tr",align:"center"},"time"),(0,s.kt)("td",{parentName:"tr",align:null},"Timestamp of ",(0,s.kt)("inlineCode",{parentName:"td"},"transaction"))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"nodes")),(0,s.kt)("td",{parentName:"tr",align:"center"},"list of nodeIDs"),(0,s.kt)("td",{parentName:"tr",align:null},"List of known nodes.")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"epoch.finalTime")),(0,s.kt)("td",{parentName:"tr",align:"center"},"time"),(0,s.kt)("td",{parentName:"tr",align:null},"Final time of ",(0,s.kt)("inlineCode",{parentName:"td"},"epoch"))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"epoch.initialTime")),(0,s.kt)("td",{parentName:"tr",align:"center"},"time"),(0,s.kt)("td",{parentName:"tr",align:null},"Initial time of ",(0,s.kt)("inlineCode",{parentName:"td"},"epoch"))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"epoch.transactions")),(0,s.kt)("td",{parentName:"tr",align:"center"},"list of TxIds"),(0,s.kt)("td",{parentName:"tr",align:null},"Set of transactions with timestamps in the interval ",(0,s.kt)("inlineCode",{parentName:"td"},"[epoch.initialTime,epoch.finalTime)"))),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:null},(0,s.kt)("inlineCode",{parentName:"td"},"input.time")),(0,s.kt)("td",{parentName:"tr",align:"center"},"time"),(0,s.kt)("td",{parentName:"tr",align:null},"Timestamp of the transaction that generated the output relative to ",(0,s.kt)("inlineCode",{parentName:"td"},"input"))))),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Table 5.3.3:")," Local Variables and Built-in Functions."),(0,s.kt)("h2",{id:"5363-pseudocode---cmana-update"},"5.3.6.3. Pseudocode - cMana Update"),(0,s.kt)("p",null,"In this section, for the sake of clarity, we introduce an example of code of the functions defined above. "),(0,s.kt)("h4",{id:"updatebasecmanatrtransaction"},(0,s.kt)("inlineCode",{parentName:"h4"},"UpdateBasecManaTr(transaction)")),(0,s.kt)("p",null,"The function ",(0,s.kt)("inlineCode",{parentName:"p"},"UpdateBasecManaTr(transaction)")," updates the vector ",(0,s.kt)("inlineCode",{parentName:"p"},"basecMana"),", pledging and revoking the base cMana relative to a transaction ",(0,s.kt)("inlineCode",{parentName:"p"},"transaction"),". "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdateBasecManaTr(transaction)\n    basecMana[transaction.cManaNode] = basecMana[transaction.cManaNode]+transaction.amount \n    FOR input in transaction.inputs\n        basecMana[input.cManaNode] = basecMana[input.cManaNode]-input.amount\n")),(0,s.kt)("h4",{id:"updatecmanatimeepoch"},(0,s.kt)("inlineCode",{parentName:"h4"},"UpdatecManaTime(epoch)")),(0,s.kt)("p",null,"The function ",(0,s.kt)("inlineCode",{parentName:"p"},"UpdatecManaTime(epoch)")," updates the vector ",(0,s.kt)("inlineCode",{parentName:"p"},"cMana"),", changing its reference time from the end of ",(0,s.kt)("inlineCode",{parentName:"p"},"epoch-1")," to the end of ",(0,s.kt)("inlineCode",{parentName:"p"},"epoch"),". "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdatecManaTime(epoch)\n    n = epoch.finalTime-epoch.initialTime\n    FOR node in nodes\n        cMana[node] = exp(-C_MANA_EMA_COEFF*n)*cMana[node]\n                        +(1-exp(-C_MANA_EMA_COEFF*n))*basecMana[node]\n")),(0,s.kt)("h4",{id:"updatecmanatrepochtransaction"},(0,s.kt)("inlineCode",{parentName:"h4"},"UpdatecManaTr(epoch,transaction)")),(0,s.kt)("p",null,"The function ",(0,s.kt)("inlineCode",{parentName:"p"},"UpdatecManaTr(epoch,transaction)")," updates the vector ",(0,s.kt)("inlineCode",{parentName:"p"},"cMana"),", pledging and revoking the cMana relative to a transaction ",(0,s.kt)("inlineCode",{parentName:"p"},"transaction"),". "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdatecManaTr(epoch,transaction)\n    n = epoch.finalTime - transaction.time\n    FOR node in nodes\n        IF basecMana[node] != basecManaOld[node]\n            cMana[node] = cMana[node]+(1-(1-C_MANA_EMA_COEFF)**n)*(basecMana[node]-basecManaOld[node])\n")),(0,s.kt)("h4",{id:"updatecmanaepoch"},(0,s.kt)("inlineCode",{parentName:"h4"},"UpdatecMana(epoch)")),(0,s.kt)("p",null,"The function ",(0,s.kt)("inlineCode",{parentName:"p"},"UpdatecMana(epoch)")," updates the vectors ",(0,s.kt)("inlineCode",{parentName:"p"},"cMana")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"basecMana"),", from the end of ",(0,s.kt)("inlineCode",{parentName:"p"},"epoch-1")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"epoch"),", pledging and revoking the base cMana and cMana relative to all the relevant transactions. "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdatecMana(epoch):\n    UpdatecManaTime(epoch)\n    IF epoch.transactions != NULL:\n        FOR transaction in epoch.transactions:\n            basecManaOld = basecMana\n            UpdateBasecManaTr(transaction)\n            UpdatecManaTr(epoch,transaction)\n")),(0,s.kt)("h3",{id:"5364-pseudocode---amana-update"},"5.3.6.4. Pseudocode - aMana Update"),(0,s.kt)("p",null,"In this section, for the sake of clarity, we introduce an example of code of the functions defined above. "),(0,s.kt)("h4",{id:"updatebaseamanatimet"},(0,s.kt)("inlineCode",{parentName:"h4"},"UpdateBaseaManaTime(t)")),(0,s.kt)("p",null,"The function ",(0,s.kt)("inlineCode",{parentName:"p"},"UpdateBaseaManaTime(t)")," updates the vector ",(0,s.kt)("inlineCode",{parentName:"p"},"baseaMana"),", changing its reference time from ",(0,s.kt)("inlineCode",{parentName:"p"},"lastUpdateTime")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"t"),". "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdateBaseaManaTime(t)\n    n = t-lastUpdateTime\n    FOR each node i\n        baseaMana[i] = baseaMana[i]*exp(-DECAY*n)  \n")),(0,s.kt)("h4",{id:"updateamanatimet"},(0,s.kt)("inlineCode",{parentName:"h4"},"UpdateaManaTime(t)")),(0,s.kt)("p",null,"The function ",(0,s.kt)("inlineCode",{parentName:"p"},"UpdateaManaTime(t)")," updates the vector ",(0,s.kt)("inlineCode",{parentName:"p"},"aMana"),", changing its reference time from ",(0,s.kt)("inlineCode",{parentName:"p"},"lastUpdateTime")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"t"),". "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdateaManaTime(t)\n    n = t-lastUpdateTime\n    IF DECAY != A_MANA_EMA_COEFF\n        FOR each node i\n            aMana[i] = exp(-A_MANA_EMA_COEFF*n)*aMana[i]+(1-exp((DECAY-A_MANA_EMA_COEFF)*n))/(A_MANA_EMA_COEFF-DECAY))*A_MANA_EMA_COEFF*baseaMana[i]\n    ELSE       \n        FOR each node i\n            aMana[i] = exp(-A_MANA_EMA_COEFF*n)*aMana[i]+ n*A_MANA_EMA_COEFF*baseaMana[i]            \n")),(0,s.kt)("h4",{id:"updatebaseamanatrtransaction"},(0,s.kt)("inlineCode",{parentName:"h4"},"UpdateBaseaManaTr(transaction)")),(0,s.kt)("p",null,"The function ",(0,s.kt)("inlineCode",{parentName:"p"},"UpdateBaseaManaTr(t,transaction)")," updates the vector ",(0,s.kt)("inlineCode",{parentName:"p"},"baseaMana"),", pledging the base aMana relative to a transaction ",(0,s.kt)("inlineCode",{parentName:"p"},"transaction"),". "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdateBaseaManaTr(transaction)\n    FOR input in transaction.inputs\n        baseaMana[transaction.aManaNode] = baseaMana[transaction.aManaNode]+exp(-DECAY*(MAX(transaction.time,lastUpdateTime)-transaction.time))*input.amount*(1-exp(-DECAY*(transaction.time-input.time))) \n")),(0,s.kt)("h4",{id:"updateamanatrtransaction"},(0,s.kt)("inlineCode",{parentName:"h4"},"UpdateaManaTr(transaction)")),(0,s.kt)("p",null,"The function ",(0,s.kt)("inlineCode",{parentName:"p"},"UpdateaManaTr(transaction)")," updates the vector ",(0,s.kt)("inlineCode",{parentName:"p"},"aMana"),", pledging the aMana relative to a transaction ",(0,s.kt)("inlineCode",{parentName:"p"},"transaction"),". "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdateaManaTr(transaction):\n    n = lastUpdateTime-transaction.time\n    IF DECAY != A_MANA_EMA_COEFF\n        aMana[transaction.aManaNode] = aMana[transaction.aManaNode]+(exp(-DECAY*n)-exp(-A_MANA_EMA_COEFF*n))/(A_MANA_EMA_COEFF-DECAY))*A_MANA_EMA_COEFF*(baseaMana[transaction.aManaNode]-baseaManaOld[transaction.aManaNode])\n    ELSE\n        aMana[aManaNode(transaction)] = aMana[transaction.aManaNode]+exp(-DECAY*n)*DECAY*A_MANA_EMA_COEFF*(baseaMana[transaction.aManaNode]-baseaManaOld[transaction.aManaNode])\n\n")),(0,s.kt)("h4",{id:"updateamanatransaction"},(0,s.kt)("inlineCode",{parentName:"h4"},"UpdateaMana(transaction)")),(0,s.kt)("p",null,"The function ",(0,s.kt)("inlineCode",{parentName:"p"},"UpdateaMana(transaction)")," updates the vectors ",(0,s.kt)("inlineCode",{parentName:"p"},"aMana")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"baseaMana"),", from ",(0,s.kt)("inlineCode",{parentName:"p"},"lastUpdateTime")," to ",(0,s.kt)("inlineCode",{parentName:"p"},"MAX(lastUpdateTime, transaction.time)"),", pledging the base aMana and aMana relative to ",(0,s.kt)("inlineCode",{parentName:"p"},"transaction"),". "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-vbnet"},"FUNCTION UpdateaMana(transaction):\n    # if the tx is not old, add it and update the vector to t   \n    IF transaction.time > lastUpdateTime:\n        UpdateBaseaManaTime(transaction.time)\n        UpdateaManaTime(transaction.time)\n        UpdateBaseaManaTr(transaction)\n        lastUpdateTime  = transaction.time        \n    # add a transaction in the past    \n    IF transaction.time < lastUpdateTime:\n        baseaManaOld = baseaMana\n        UpdateBaseaManaTr(transaction)\n        UpdateaManaTr(transaction)\n")))}h.isMDXComponent=!0}}]);