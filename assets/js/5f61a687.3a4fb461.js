"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[83992],{58611:function(e,n,t){t.r(n),t.d(n,{contentTitle:function(){return p},default:function(){return h},frontMatter:function(){return u},metadata:function(){return f},toc:function(){return m}});var i=t(87462),a=t(63366),r=(t(67294),t(3905)),o=t(66816),l=t(71871),s=t(34369),d=t(8813),c=["components"],u={title:"Verifiable Presentations",sidebar_label:"Verifiable Presentations",description:"Explain how a VC is created and verified",image:"/img/Identity_icon.png",keywords:["verifiable","presentations"]},p=void 0,f={unversionedId:"verifiable_credentials/verifiable_presentations",id:"verifiable_credentials/verifiable_presentations",isDocsHomePage:!1,title:"Verifiable Presentations",description:"Explain how a VC is created and verified",source:"@site/external/identity.rs/documentation/docs/verifiable_credentials/verifiable_presentations.mdx",sourceDirName:"verifiable_credentials",slug:"/verifiable_credentials/verifiable_presentations",permalink:"/identity.rs/verifiable_credentials/verifiable_presentations",editUrl:"https://github.com/iotaledger/identity.rs/edit/dev/external/identity.rs/documentation/docs/verifiable_credentials/verifiable_presentations.mdx",tags:[],version:"current",frontMatter:{title:"Verifiable Presentations",sidebar_label:"Verifiable Presentations",description:"Explain how a VC is created and verified",image:"/img/Identity_icon.png",keywords:["verifiable","presentations"]},sidebar:"docs",previous:{title:"Merkle Key Collection",permalink:"/identity.rs/verifiable_credentials/merkle_key_collection"},next:{title:"Overview",permalink:"/identity.rs/did_communications/overview"}},m=[{value:"Example",id:"example",children:[{value:"Account Module (Recommended)",id:"account-module-recommended",children:[],level:3},{value:"Low-level API",id:"low-level-api",children:[],level:3}],level:2}],v={toc:m};function h(e){var n=e.components,t=(0,a.Z)(e,c);return(0,r.kt)("wrapper",(0,i.Z)({},v,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"TODO: Explain the need for and"),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,"This example shows how you can create and validate a Verifiable Presentation. A Verifiable Presentation is the format in which you can share a (collection of) Verifiable Credential(s). It is signed by the subject, to prove control over the Verifiable Credential with a nonce or timestamp."),(0,r.kt)("h3",{id:"account-module-recommended"},"Account Module (Recommended)"),(0,r.kt)(s.Z,{className:"language-rust",mdxType:"CodeBlock"},d.Z),(0,r.kt)("h3",{id:"low-level-api"},"Low-level API"),(0,r.kt)(o.Z,{groupId:"programming-languages",defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Node.js",value:"nodejs"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"rust",mdxType:"TabItem"},(0,r.kt)(s.Z,{className:"language-rust",mdxType:"CodeBlock"},'// Copyright 2020-2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! A Verifiable Presentation (VP) represents a bundle of one or more Verifiable Credentials.\n//! This example demonstrates building and usage of VPs.\n//!\n//! cargo run --example create_vp\n\nuse identity::core::ToJson;\nuse identity::core::Url;\nuse identity::credential::Credential;\nuse identity::credential::Presentation;\nuse identity::credential::PresentationBuilder;\nuse identity::iota::ClientMap;\nuse identity::iota::CredentialValidator;\nuse identity::iota::PresentationValidation;\nuse identity::iota::Receipt;\nuse identity::prelude::*;\n\nmod common;\nmod create_did;\n\npub async fn create_vp() -> Result<Presentation> {\n  // Create a signed DID Document/KeyPair for the credential issuer (see create_did.rs).\n  let (doc_iss, key_iss, _): (IotaDocument, KeyPair, Receipt) = create_did::run().await?;\n\n  // Create a signed DID Document/KeyPair for the credential subject (see create_did.rs).\n  let (doc_sub, key_sub, _): (IotaDocument, KeyPair, Receipt) = create_did::run().await?;\n\n  // Create an unsigned Credential with claims about `subject` specified by `issuer`.\n  let mut credential: Credential = common::issue_degree(&doc_iss, &doc_sub)?;\n\n  // Sign the Credential with the issuers private key.\n  doc_iss.sign_data(\n    &mut credential,\n    key_iss.private(),\n    doc_iss.default_signing_method()?.id(),\n  )?;\n\n  // Create an unsigned Presentation from the previously issued Verifiable Credential.\n  let mut presentation: Presentation = PresentationBuilder::default()\n    .id(Url::parse("asdf:foo:a87w3guasbdfuasbdfs")?)\n    .holder(Url::parse(doc_sub.id().as_ref())?)\n    .credential(credential)\n    .build()?;\n\n  // Sign the presentation with the holders private key.\n  doc_sub.sign_data(\n    &mut presentation,\n    key_sub.private(),\n    doc_sub.default_signing_method()?.id(),\n  )?;\n\n  Ok(presentation)\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n  // Create a client instance to send messages to the Tangle.\n  let client: ClientMap = ClientMap::new();\n\n  // Issue a Verifiable Presentation with a newly created DID Document.\n  let presentation: Presentation = create_vp().await?;\n\n  // Convert the Verifiable Presentation to JSON and "exchange" with a verifier\n  let presentation_json: String = presentation.to_json()?;\n\n  // Create a `CredentialValidator` instance to fetch and validate all\n  // associated DID Documents from the Tangle.\n  let validator: CredentialValidator<ClientMap> = CredentialValidator::new(&client);\n\n  // Perform the validation operation.\n  let validation: PresentationValidation = validator.check_presentation(&presentation_json).await?;\n  println!("validation = {:#?}", validation);\n  assert!(validation.verified);\n\n  println!("Presentation Validation > {:#?}", validation);\n\n  Ok(())\n}\n')),(0,r.kt)(l.Z,{value:"nodejs",mdxType:"TabItem"},(0,r.kt)(s.Z,{className:"language-javascript",mdxType:"CodeBlock"},"// Copyright 2020-2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport { Client, Config, VerifiablePresentation } from '@iota/identity-wasm';\nimport { createVC } from './create_vc';\n\n/**\n    This example shows how to create a Verifiable Presentation and validate it.\n    A Verifiable Presentation is the format in which a (collection of) Verifiable Credential(s) gets shared.\n    It is signed by the subject, to prove control over the Verifiable Credential with a nonce or timestamp.\n\n    @param {{defaultNodeURL: string, explorerURL: string, network: Network}} clientConfig\n**/\nasync function createVP(clientConfig) {\n    // Create a default client configuration from the parent config network.\n    const config = Config.fromNetwork(clientConfig.network);\n\n    // Create a client instance to publish messages to the Tangle.\n    const client = Client.fromConfig(config);\n\n    // Creates new identities (See \"createVC\" example)\n    const {alice, signedVc} = await createVC(clientConfig);\n\n    // Create a Verifiable Presentation from the Credential - signed by Alice's key\n    // TODO: Sign with a challenge\n    const unsignedVp = new VerifiablePresentation(alice.doc, signedVc.toJSON())\n\n    const signedVp = alice.doc.signPresentation(unsignedVp, {\n        method: \"#sign-0\",\n        private: alice.key.private,\n    })\n\n    // Check the validation status of the Verifiable Presentation\n    const result = await client.checkPresentation(signedVp.toString());\n\n    console.log(`VP verification result: ${result.verified}`);\n}\n\nexport {createVP};\n"))))}h.isMDXComponent=!0},71871:function(e,n,t){var i=t(67294);n.Z=function(e){var n=e.children,t=e.hidden,a=e.className;return i.createElement("div",{role:"tabpanel",hidden:t,className:a},n)}},66816:function(e,n,t){t.d(n,{Z:function(){return p}});var i=t(87462),a=t(67294),r=t(5730),o=t(54179);var l=function(){var e=(0,a.useContext)(o.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},s=t(86881),d=t(86010),c="tabItem_1uMI";function u(e){var n,t,i,r=e.lazy,o=e.block,u=e.defaultValue,p=e.values,f=e.groupId,m=e.className,v=a.Children.map(e.children,(function(e){if((0,a.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),h=null!=p?p:v.map((function(e){var n=e.props;return{value:n.value,label:n.label}})),g=(0,s.lx)(h,(function(e,n){return e.value===n.value}));if(g.length>0)throw new Error('Docusaurus error: Duplicate values "'+g.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var b=null===u?u:null!=(n=null!=u?u:null==(t=v.find((function(e){return e.props.default})))?void 0:t.props.value)?n:null==(i=v[0])?void 0:i.props.value;if(null!==b&&!h.some((function(e){return e.value===b})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+b+'" but none of its children has the corresponding value. Available values are: '+h.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var y=l(),_=y.tabGroupChoices,w=y.setTabGroupChoices,C=(0,a.useState)(b),k=C[0],D=C[1],V=[],I=(0,s.o5)().blockElementScrollPositionUntilNextRender;if(null!=f){var P=_[f];null!=P&&P!==k&&h.some((function(e){return e.value===P}))&&D(P)}var x=function(e){var n=e.currentTarget,t=V.indexOf(n),i=h[t].value;i!==k&&(I(n),D(i),null!=f&&w(f,i))},T=function(e){var n,t=null;switch(e.key){case"ArrowRight":var i=V.indexOf(e.currentTarget)+1;t=V[i]||V[0];break;case"ArrowLeft":var a=V.indexOf(e.currentTarget)-1;t=V[a]||V[V.length-1]}null==(n=t)||n.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,d.Z)("tabs",{"tabs--block":o},m)},h.map((function(e){var n=e.value,t=e.label;return a.createElement("li",{role:"tab",tabIndex:k===n?0:-1,"aria-selected":k===n,className:(0,d.Z)("tabs__item",c,{"tabs__item--active":k===n}),key:n,ref:function(e){return V.push(e)},onKeyDown:T,onFocus:x,onClick:x},null!=t?t:n)}))),r?(0,a.cloneElement)(v.filter((function(e){return e.props.value===k}))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},v.map((function(e,n){return(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==k})}))))}function p(e){var n=(0,r.Z)();return a.createElement(u,(0,i.Z)({key:String(n)},e))}},54179:function(e,n,t){var i=(0,t(67294).createContext)(void 0);n.Z=i},8813:function(e,n){n.Z='// Copyright 2020-2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! cargo run --example account_signing\n\nuse std::path::PathBuf;\n\nuse identity::account::Account;\nuse identity::account::AccountStorage;\nuse identity::account::IdentitySetup;\nuse identity::account::Result;\nuse identity::core::json;\nuse identity::core::FromJson;\nuse identity::core::Url;\nuse identity::credential::Credential;\nuse identity::credential::Subject;\nuse identity::crypto::KeyPair;\nuse identity::did::DID;\nuse identity::iota::IotaDID;\nuse identity::iota::IotaDocument;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n  pretty_env_logger::init();\n\n  // ===========================================================================\n  // Create Identity - Similar to create_did example\n  // ===========================================================================\n\n  // Stronghold settings\n  let stronghold_path: PathBuf = "./example-strong.hodl".into();\n  let password: String = "my-password".into();\n\n  // Create a new Account with stronghold storage.\n  let mut account: Account = Account::builder()\n    .storage(AccountStorage::Stronghold(stronghold_path, Some(password)))\n    .create_identity(IdentitySetup::default())\n    .await?;\n\n  // ===========================================================================\n  // Signing Example\n  // ===========================================================================\n\n  // Add a new Ed25519 Verification Method to the identity\n  account\n    .update_identity()\n    .create_method()\n    .fragment("key-1")\n    .apply()\n    .await?;\n\n  // Create a subject DID for the recipient of a `UniversityDegree` credential.\n  let subject_key: KeyPair = KeyPair::new_ed25519()?;\n  let subject_did: IotaDID = IotaDID::new(subject_key.public().as_ref())?;\n\n  // Create the actual Verifiable Credential subject.\n  let subject: Subject = Subject::from_json_value(json!({\n    "id": subject_did.as_str(),\n    "degree": {\n      "type": "BachelorDegree",\n      "name": "Bachelor of Science and Arts"\n    }\n  }))?;\n\n  // Issue an unsigned Credential...\n  let mut credential: Credential = Credential::builder(Default::default())\n    .issuer(Url::parse(account.did().as_str())?)\n    .type_("UniversityDegreeCredential")\n    .subject(subject)\n    .build()?;\n\n  // ...and sign the Credential with the previously created Verification Method\n  account.sign("key-1", &mut credential).await?;\n\n  println!("[Example] Local Credential = {:#}", credential);\n\n  // Fetch the DID Document from the Tangle\n  //\n  // This is an optional step to ensure DID Document consistency.\n  let resolved: IotaDocument = account.resolve_identity().await?;\n\n  // Retrieve the DID from the newly created identity.\n  let iota_did: &IotaDID = account.did();\n\n  // Prints the Identity Resolver Explorer URL.\n  // The entire history can be observed on this page by clicking "Loading History".\n  println!(\n    "[Example] Explore the DID Document = {}{}",\n    iota_did.network()?.explorer_url().unwrap().to_string(),\n    iota_did.to_string()\n  );\n\n  // Ensure the resolved DID Document can verify the credential signature\n  let verified: bool = resolved.verify_data(&credential).is_ok();\n\n  println!("[Example] Credential Verified = {}", verified);\n\n  Ok(())\n}\n'}}]);