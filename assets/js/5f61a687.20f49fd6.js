"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[83992],{58611:function(e,n,t){t.r(n),t.d(n,{assets:function(){return m},contentTitle:function(){return p},default:function(){return g},frontMatter:function(){return u},metadata:function(){return f},toc:function(){return h}});var i=t(83117),a=t(80102),r=(t(67294),t(3905)),o=t(76018),l=t(71871),s=t(74606),d=t(8813),c=["components"],u={title:"Verifiable Presentations",sidebar_label:"Verifiable Presentations",description:"Explain how a VC is created and verified",image:"/img/Identity_icon.png",keywords:["verifiable","presentations"]},p=void 0,f={unversionedId:"verifiable_credentials/verifiable_presentations",id:"verifiable_credentials/verifiable_presentations",title:"Verifiable Presentations",description:"Explain how a VC is created and verified",source:"@site/external/identity.rs/documentation/docs/verifiable_credentials/verifiable_presentations.mdx",sourceDirName:"verifiable_credentials",slug:"/verifiable_credentials/verifiable_presentations",permalink:"/identity.rs/verifiable_credentials/verifiable_presentations",editUrl:"https://github.com/iotaledger/identity.rs/edit/dev/external/identity.rs/documentation/docs/verifiable_credentials/verifiable_presentations.mdx",tags:[],version:"current",frontMatter:{title:"Verifiable Presentations",sidebar_label:"Verifiable Presentations",description:"Explain how a VC is created and verified",image:"/img/Identity_icon.png",keywords:["verifiable","presentations"]},sidebar:"docs",previous:{title:"Merkle Key Collection",permalink:"/identity.rs/verifiable_credentials/merkle_key_collection"},next:{title:"Overview",permalink:"/identity.rs/did_communications/overview"}},m={},h=[{value:"Example",id:"example",level:2},{value:"Account Module (Recommended)",id:"account-module-recommended",level:3},{value:"Low-level API",id:"low-level-api",level:3}],v={toc:h};function g(e){var n=e.components,t=(0,a.Z)(e,c);return(0,r.kt)("wrapper",(0,i.Z)({},v,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"TODO: Explain the need for and"),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,"This example shows how you can create and validate a Verifiable Presentation. A Verifiable Presentation is the format in which you can share a (collection of) Verifiable Credential(s). It is signed by the subject, to prove control over the Verifiable Credential with a nonce or timestamp."),(0,r.kt)("h3",{id:"account-module-recommended"},"Account Module (Recommended)"),(0,r.kt)(s.Z,{className:"language-rust",mdxType:"CodeBlock"},d.Z),(0,r.kt)("h3",{id:"low-level-api"},"Low-level API"),(0,r.kt)(o.Z,{groupId:"programming-languages",defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Node.js",value:"nodejs"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"rust",mdxType:"TabItem"},(0,r.kt)(s.Z,{className:"language-rust",mdxType:"CodeBlock"},'// Copyright 2020-2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! A Verifiable Presentation (VP) represents a bundle of one or more Verifiable Credentials.\n//! This example demonstrates building and usage of VPs.\n//!\n//! cargo run --example create_vp\n\nuse identity::core::ToJson;\nuse identity::core::Url;\nuse identity::credential::Credential;\nuse identity::credential::Presentation;\nuse identity::credential::PresentationBuilder;\nuse identity::crypto::SignatureOptions;\nuse identity::did::verifiable::VerifierOptions;\nuse identity::iota::CredentialValidator;\nuse identity::iota::PresentationValidation;\nuse identity::iota::Receipt;\nuse identity::iota::Resolver;\nuse identity::prelude::*;\n\nmod common;\nmod create_did;\n\npub async fn create_vp() -> Result<Presentation> {\n  // Create a signed DID Document/KeyPair for the credential issuer (see create_did.rs).\n  let (doc_iss, key_iss, _): (IotaDocument, KeyPair, Receipt) = create_did::run().await?;\n\n  // Create a signed DID Document/KeyPair for the credential subject (see create_did.rs).\n  let (doc_sub, key_sub, _): (IotaDocument, KeyPair, Receipt) = create_did::run().await?;\n\n  // Create an unsigned Credential with claims about `subject` specified by `issuer`.\n  let mut credential: Credential = common::issue_degree(&doc_iss, &doc_sub)?;\n\n  // Sign the Credential with the issuers private key.\n  doc_iss.sign_data(\n    &mut credential,\n    key_iss.private(),\n    doc_iss.default_signing_method()?.id(),\n    SignatureOptions::default(),\n  )?;\n\n  // Create an unsigned Presentation from the previously issued Verifiable Credential.\n  let mut presentation: Presentation = PresentationBuilder::default()\n    .id(Url::parse("asdf:foo:a87w3guasbdfuasbdfs")?)\n    .holder(Url::parse(doc_sub.id().as_ref())?)\n    .credential(credential)\n    .build()?;\n\n  // Sign the presentation with the holders private key.\n  //\n  // Optionally include a challenge from the requester in the signature.\n  // A unique random challenge generated by the requester per presentation can mitigate replay attacks\n  // (along with other properties like `expires` and `domain`).\n  doc_sub.sign_data(\n    &mut presentation,\n    key_sub.private(),\n    doc_sub.default_signing_method()?.id(),\n    SignatureOptions::new().challenge("475a7984-1bb5-4c4c-a56f-822bccd46440".to_owned()),\n  )?;\n\n  Ok(presentation)\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n  // Issue a Verifiable Presentation with a newly created DID Document.\n  let presentation: Presentation = create_vp().await?;\n\n  // Convert the Verifiable Presentation to JSON and "exchange" with a verifier\n  let presentation_json: String = presentation.to_json()?;\n\n  // Create a `CredentialValidator` instance to fetch and validate all\n  // associated DID Documents from the Tangle.\n  let resolver: Resolver = Resolver::new().await?;\n  let validator: CredentialValidator<Resolver> = CredentialValidator::new(&resolver);\n\n  // Validate the presentation and all the credentials included in it.\n  //\n  // Also verify the challenge matches.\n  let validation: PresentationValidation = validator\n    .check_presentation(\n      &presentation_json,\n      VerifierOptions::new().challenge("475a7984-1bb5-4c4c-a56f-822bccd46440".to_owned()),\n    )\n    .await?;\n  println!("validation = {:#?}", validation);\n  assert!(validation.verified);\n\n  println!("Presentation Validation > {:#?}", validation);\n\n  Ok(())\n}\n')),(0,r.kt)(l.Z,{value:"nodejs",mdxType:"TabItem"},(0,r.kt)(s.Z,{className:"language-javascript",mdxType:"CodeBlock"},'// Copyright 2020-2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport {Client, Config, Presentation, SignatureOptions, VerifierOptions} from \'@iota/identity-wasm\';\nimport {createVC} from \'./create_vc\';\n\n/**\n This example shows how to create a Verifiable Presentation and validate it.\n A Verifiable Presentation is the format in which a (collection of) Verifiable Credential(s) gets shared.\n It is signed by the subject, to prove control over the Verifiable Credential with a nonce or timestamp.\n\n @param {{network: Network, explorer: ExplorerUrl}} clientConfig\n **/\nasync function createVP(clientConfig) {\n    // Create a default client configuration from the parent config network.\n    const config = Config.fromNetwork(clientConfig.network);\n\n    // Create a client instance to publish messages to the Tangle.\n    const client = Client.fromConfig(config);\n\n    // Creates new identities (See "createVC" example)\n    const {alice, signedVc} = await createVC(clientConfig);\n\n    // Create a Verifiable Presentation from the Credential\n    const unsignedVp = new Presentation(alice.doc, signedVc.toJSON())\n\n    // Sign the presentation with the holders private key.\n    //\n    // Optionally include a challenge from the requester in the signature.\n    // A unique random challenge generated by the requester per presentation can mitigate replay attacks\n    // (along with other properties like `expires` and `domain`).\n    const signedVp = alice.doc.signPresentation(unsignedVp, {\n        method: "#sign-0",\n        private: alice.key.private,\n    }, new SignatureOptions({\n        challenge: "475a7984-1bb5-4c4c-a56f-822bccd46440"\n    }))\n\n    // Validate the presentation and all the credentials included in it.\n    //\n    // Also verify the challenge matches.\n    const result = await client.checkPresentation(signedVp.toString(), new VerifierOptions({\n        challenge: "475a7984-1bb5-4c4c-a56f-822bccd46440"\n    }));\n\n    console.log(`VP verification result: ${result.verified}`);\n}\n\nexport {createVP};\n'))))}g.isMDXComponent=!0},71871:function(e,n,t){t.d(n,{Z:function(){return a}});var i=t(67294);function a(e){var n=e.children,t=e.hidden,a=e.className;return i.createElement("div",{role:"tabpanel",hidden:t,className:a},n)}},76018:function(e,n,t){t.d(n,{Z:function(){return c}});var i=t(83117),a=t(67294),r=t(5730),o=t(10109),l=t(86010),s="tabItem_LplD";function d(e){var n,t,r,d=e.lazy,c=e.block,u=e.defaultValue,p=e.values,f=e.groupId,m=e.className,h=a.Children.map(e.children,(function(e){if((0,a.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),v=null!=p?p:h.map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes}})),g=(0,o.lx)(v,(function(e,n){return e.value===n.value}));if(g.length>0)throw new Error('Docusaurus error: Duplicate values "'+g.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var b=null===u?u:null!=(n=null!=u?u:null==(t=h.find((function(e){return e.props.default})))?void 0:t.props.value)?n:null==(r=h[0])?void 0:r.props.value;if(null!==b&&!v.some((function(e){return e.value===b})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+b+'" but none of its children has the corresponding value. Available values are: '+v.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var y=(0,o.UB)(),_=y.tabGroupChoices,w=y.setTabGroupChoices,k=(0,a.useState)(b),C=k[0],V=k[1],D=[],x=(0,o.o5)().blockElementScrollPositionUntilNextRender;if(null!=f){var I=_[f];null!=I&&I!==C&&v.some((function(e){return e.value===I}))&&V(I)}var P=function(e){var n=e.currentTarget,t=D.indexOf(n),i=v[t].value;i!==C&&(x(n),V(i),null!=f&&w(f,i))},S=function(e){var n,t=null;switch(e.key){case"ArrowRight":var i=D.indexOf(e.currentTarget)+1;t=D[i]||D[0];break;case"ArrowLeft":var a=D.indexOf(e.currentTarget)-1;t=D[a]||D[D.length-1]}null==(n=t)||n.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,l.Z)("tabs",{"tabs--block":c},m)},v.map((function(e){var n=e.value,t=e.label,r=e.attributes;return a.createElement("li",(0,i.Z)({role:"tab",tabIndex:C===n?0:-1,"aria-selected":C===n,key:n,ref:function(e){return D.push(e)},onKeyDown:S,onFocus:P,onClick:P},r,{className:(0,l.Z)("tabs__item",s,null==r?void 0:r.className,{"tabs__item--active":C===n})}),null!=t?t:n)}))),d?(0,a.cloneElement)(h.filter((function(e){return e.props.value===C}))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},h.map((function(e,n){return(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==C})}))))}function c(e){var n=(0,r.Z)();return a.createElement(d,(0,i.Z)({key:String(n)},e))}},8813:function(e,n){n.Z='// Copyright 2020-2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! cargo run --example account_signing\n\nuse std::path::PathBuf;\n\nuse identity::account::Account;\nuse identity::account::AccountStorage;\nuse identity::account::IdentitySetup;\nuse identity::account::Result;\nuse identity::core::json;\nuse identity::core::FromJson;\nuse identity::core::Url;\nuse identity::credential::Credential;\nuse identity::credential::Subject;\nuse identity::crypto::KeyPair;\nuse identity::crypto::SignatureOptions;\nuse identity::did::verifiable::VerifierOptions;\nuse identity::did::DID;\nuse identity::iota::ExplorerUrl;\nuse identity::iota::IotaDID;\nuse identity::iota::ResolvedIotaDocument;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n  pretty_env_logger::init();\n\n  // ===========================================================================\n  // Create Identity - Similar to create_did example\n  // ===========================================================================\n\n  // Stronghold settings\n  let stronghold_path: PathBuf = "./example-strong.hodl".into();\n  let password: String = "my-password".into();\n\n  // Create a new Account with stronghold storage.\n  let mut account: Account = Account::builder()\n    .storage(AccountStorage::Stronghold(stronghold_path, Some(password), None))\n    .create_identity(IdentitySetup::default())\n    .await?;\n\n  // ===========================================================================\n  // Signing Example\n  // ===========================================================================\n\n  // Add a new Ed25519 Verification Method to the identity\n  account\n    .update_identity()\n    .create_method()\n    .fragment("key-1")\n    .apply()\n    .await?;\n\n  // Create a subject DID for the recipient of a `UniversityDegree` credential.\n  let subject_key: KeyPair = KeyPair::new_ed25519()?;\n  let subject_did: IotaDID = IotaDID::new(subject_key.public().as_ref())?;\n\n  // Create the actual Verifiable Credential subject.\n  let subject: Subject = Subject::from_json_value(json!({\n    "id": subject_did.as_str(),\n    "degree": {\n      "type": "BachelorDegree",\n      "name": "Bachelor of Science and Arts"\n    }\n  }))?;\n\n  // Issue an unsigned Credential...\n  let mut credential: Credential = Credential::builder(Default::default())\n    .issuer(Url::parse(account.did().as_str())?)\n    .type_("UniversityDegreeCredential")\n    .subject(subject)\n    .build()?;\n\n  // ...and sign the Credential with the previously created Verification Method\n  account\n    .sign("key-1", &mut credential, SignatureOptions::default())\n    .await?;\n\n  println!("[Example] Local Credential = {:#}", credential);\n\n  // Fetch the DID Document from the Tangle\n  //\n  // This is an optional step to ensure DID Document consistency.\n  let resolved: ResolvedIotaDocument = account.resolve_identity().await?;\n\n  // Retrieve the DID from the newly created identity.\n  let iota_did: &IotaDID = account.did();\n\n  // Prints the Identity Resolver Explorer URL.\n  // The entire history can be observed on this page by clicking "Loading History".\n  let explorer: &ExplorerUrl = ExplorerUrl::mainnet();\n  println!(\n    "[Example] Explore the DID Document = {}",\n    explorer.resolver_url(iota_did)?\n  );\n\n  // Ensure the resolved DID Document can verify the credential signature\n  let verified: bool = resolved\n    .document\n    .verify_data(&credential, &VerifierOptions::default())\n    .is_ok();\n\n  println!("[Example] Credential Verified = {}", verified);\n\n  Ok(())\n}\n'}}]);