"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[35832],{90672:function(e,t,a){a.r(t),a.d(t,{assets:function(){return c},contentTitle:function(){return l},default:function(){return d},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return h}});var n=a(87462),i=a(63366),r=(a(67294),a(3905)),s=["components"],o={description:"Since every node might have a slightly different perception of the Tangle at a given time, a notion of Finality is necessary to guarantee consensus on the Tangle and its ledger state.",image:"https://user-images.githubusercontent.com/11289354/112409357-518e9480-8d54-11eb-8a40-19f4ab33ea35.png",slug:"6.4Finalization",keywords:["approval weight","finality","node","message","branch","ledger state","active consensus mana"]},l="6.4 Approval Weight and Finality",p={unversionedId:"6.4 Finalization",id:"6.4 Finalization",title:"6.4 Approval Weight and Finality",description:"Since every node might have a slightly different perception of the Tangle at a given time, a notion of Finality is necessary to guarantee consensus on the Tangle and its ledger state.",source:"@site/content/build/iota-2.0-research-specifications/6.4 Finalization.md",sourceDirName:".",slug:"/6.4Finalization",permalink:"/IOTA-2.0-Research-Specifications/6.4Finalization",draft:!1,editUrl:"https://github.com/iotaledger/IOTA-2.0-Research-Specifications/edit/main/content/build/iota-2.0-research-specifications/6.4 Finalization.md",tags:[],version:"current",frontMatter:{description:"Since every node might have a slightly different perception of the Tangle at a given time, a notion of Finality is necessary to guarantee consensus on the Tangle and its ledger state.",image:"https://user-images.githubusercontent.com/11289354/112409357-518e9480-8d54-11eb-8a40-19f4ab33ea35.png",slug:"6.4Finalization",keywords:["approval weight","finality","node","message","branch","ledger state","active consensus mana"]},sidebar:"tutorialSidebar",previous:{title:"6.3 Fast Probabilistic Consensus",permalink:"/IOTA-2.0-Research-Specifications/6.3FastProbabilisticConsensus"},next:{title:"6.5 Distributed Random Number Generator",permalink:"/IOTA-2.0-Research-Specifications/6.5dRNG"}},c={},h=[{value:"6.4.1 Introduction",id:"641-introduction",level:2},{value:"6.4.2 Definitions",id:"642-definitions",level:2},{value:"6.4.2 Approval Weight",id:"642-approval-weight",level:2},{value:"6.4.3 Finality",id:"643-finality",level:2},{value:"6.4.4 Markers Application to Finality",id:"644-markers-application-to-finality",level:2},{value:"6.4.5 Liked and Monotonically Liked",id:"645-liked-and-monotonically-liked",level:2}],m={toc:h};function d(e){var t=e.components,a=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"64-approval-weight-and-finality"},"6.4 Approval Weight and Finality"),(0,r.kt)("h2",{id:"641-introduction"},"6.4.1 Introduction"),(0,r.kt)("p",null,"This part of the specifications defines the ",(0,r.kt)("em",{parentName:"p"},"Approval Weight")," tool, which allows the notion of ",(0,r.kt)("em",{parentName:"p"},"Finality"),".  As every node might have slightly different perceptions of the Tangle at a given time, such a notion is necessary to guarantee consensus on the Tangle and its ledger state. "),(0,r.kt)("p",null,"The intuition behind the approval weight of a given message is that the more influential messages are approving a given message, the more trustworthy such a message will be for the other nodes, and thus the higher the probability that this message branch will be included in the main branch, i.e., will update the ledger state permanently. More details on branches and ledger state may be found in ",(0,r.kt)("a",{parentName:"p",href:"./5.2LedgerState"},"Section 5.2 - Ledger State"),"."),(0,r.kt)("p",null,"The approval weight tool is inspired by the confirmation confidence tool, initially defined in the legacy ",(0,r.kt)("a",{parentName:"p",href:"https://assets.ctfassets.net/r1dr6vzfxhev/2t4uxvsIqk0EUau6g2sw0g/45eae33637ca92f85dd9f4a3a218e1ec/iota1_4_3.pdf"},"Tangle whitepaper"),". However, unlike confirmation confidence which only considered the weight of the future cone of a message to decide if it was final, the approval weight now considers the proportion of approving active consensus Mana, making the protocol more robust against spam and Sybil attacks. "),(0,r.kt)("p",null,"The Approval Weight and Finality specification depends on the following specifications:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./4.7Markers"},"4.7 - Markers")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./5.2LedgerState"},"5.2 - Ledger State")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./5.3Mana"},"5.3 - Mana")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./6.1ObjectsofConsensus"},"6.1 - Object of Consensus")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"./6.3FastProbabilisticConsensus"},"6.3 - Fast Probabilistic Consensus"))),(0,r.kt)("h2",{id:"642-definitions"},"6.4.2 Definitions"),(0,r.kt)("p",null,"To define approval weight, we first need to understand what it means to support a message, we require some concepts of branches from ",(0,r.kt)("a",{parentName:"p",href:"./5.2LedgerState"},"Section 5.2 - Ledger State"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Conflict:")," Two transactions conflict if they consume the same output. A conflict is a transaction that conflicts with another transaction. A transaction ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"x")," conflicts with a branch ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"B")," if the set of conflicts in ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"x"),"'s UTXO past cone and the set of conflicts in ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"B")," conflict.  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Node Approval:")," We say that a node approves a given message ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"x")," if it has issued a message ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"y")," in the strong future cone of ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"x"),".  A node approves a transaction if it approves some message containing that transaction.  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Conflict Supporter:")," A node supports a conflict if:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"It issued a message approving a message containing that transaction."),(0,r.kt)("li",{parentName:"ul"},"It has not issued a message on a conflicting branch with a more recent timestamp or with the same timestamp but greater message ID.  "))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Branch Supporter:")," A node supports a branch if it supports all of its conflicts.  Equivalently, the supporters of a branch are the intersection of all the supporters of its conflicts.  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Message Supporter:")," The supporters of a message is the intersection of the approvers of the message, and the supporter of its branch. "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Active Consensus Mana:"),"  The active consensus Mana is defined as the sum of the consensus Mana of all nodes that issued messages during the second last complete epoch ",(0,r.kt)("inlineCode",{parentName:"li"},"cepoch-2"),", before the current epoch ",(0,r.kt)("inlineCode",{parentName:"li"},"cepoch"),".  We say that a node that has not issued a message within that epoch has 0 active consensus mana. See ",(0,r.kt)("a",{parentName:"li",href:"./5.3Mana"},"Section 5.3 - Mana"),".")),(0,r.kt)("p",null,"To be clear a node cannot be a  supporter of two conflicting transactions.  If it approves two messages with conflicting transactions,  it supports the one it more recently references (with respect to the timestamp). In the case where the node more recently supported an incompatible message in a different conflict set, then it doesn't support any of the messages.  When a new message is booked, the node goes to the message's branch in the branch DAG and walks through the branch's history giving support to all the conflicts in its past cone and revoking support from conflicting branches.  "),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://user-images.githubusercontent.com/11289354/112409357-518e9480-8d54-11eb-8a40-19f4ab33ea35.png"},(0,r.kt)("img",{parentName:"a",src:"https://user-images.githubusercontent.com/11289354/112409357-518e9480-8d54-11eb-8a40-19f4ab33ea35.png",alt:"ApprovalWeight"}))),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Image 6.4.1:")," An example of how the propagation will look like. "),(0,r.kt)("p",null,"In Image 6.4.1, the green node issued ",(0,r.kt)("strong",{parentName:"p"},"message 1")," and attached it to ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1.1 + Branch 4.1.1"),". Thus, green node is a supporter of ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1.1 + Branch 4.1.1"),", and it's also a supporter of the parent branches, which are (from top to bottom) ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4.1.1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1.1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4.1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1"),", and ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4"),"."),(0,r.kt)("p",null,"Later, the green node issued ",(0,r.kt)("strong",{parentName:"p"},"message 2")," and attached it to ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4.1.2"),". This makes the green node a supporter of ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4.1.2"),", however, ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4.1.1")," is conflicting with ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4.1.2"),", which makes green node not a supporter of ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 4.1.1"),", and therefore the support to ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1.1 + Branch 4.1.1")," is removed as well. "),(0,r.kt)("p",null,"Finally, green nodes issued ",(0,r.kt)("strong",{parentName:"p"},"message 3"),", which is in ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 2"),". Now the green node is a supporter of ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 2"),", and no longer a supporter of ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1"),", since ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1")," is conflicting with ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 2"),". Note that, this supporter removal will propagate to child branches. Thus, green node is removed from ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 1.1"),". "),(0,r.kt)("p",null,"Since ",(0,r.kt)("inlineCode",{parentName:"p"},"Branch 3"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"4"),", and both of their child branches have nothing to do with this attachment, the supporter status remains. "),(0,r.kt)("h2",{id:"642-approval-weight"},"6.4.2 Approval Weight"),(0,r.kt)("p",null,"The approval weight of a conflict (resp. branch or message) is the dot product of the vectors of supporters and the normalized consensus Mana vector (see ",(0,r.kt)("a",{parentName:"p",href:"./5.3Mana"},"Section 5.3 - Mana"),"). Equivalently, the approval weight is the proportion of active consensus Mana that belongs to the supporters of the conflict (resp. branch or message)."),(0,r.kt)("p",null,"We will use ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},"\\text{AW}(x)")," to represent the approval weight of a message or branch ",(0,r.kt)("span",{parentName:"p",className:"math math-inline"},"x"),". There are several important facts to state about approval weight:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Approval weight range"),": The approval weight is always between ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"0")," and ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"1"),", and thus can be expressed as a percentage.  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Approval weight equivalency"),": For a conflict ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"x")," attached once in a message ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"m"),", the following are the same: the approval weight of ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"x"),", the approval weight of the conflict branch defined by ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"x"),", and the approval weight of the message ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"m"),". "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Tangle Monotonicity:")," The approval weight of a message is smaller than its past cone, i.e. if message ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"x")," approves message ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"y"),", then ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"\\text{AW}(y)\\geq \\text{AW}(x)"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Branch Monotonicity:")," The approval weight of a branch is greater than the branches in pastcone on the branch DAG, i.e., if branch ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"B")," contains branch ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"C"),", then ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"\\text{AW}(C)\\geq \\text{AW}(B)"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"No Time Monotonicity:")," The approval weight of a fixed message or branch ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"x")," does not necessarily grow with time because of the nodes' active consensus Mana fluctuates and support can be revoked."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Approval weight inequalities:"),"  For any message ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"m")," and its branch ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"B"),", we have ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"\\text{AW}(B)\\geq \\text{AW}(m)"),". Similarly, for any conflict ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"x")," within a branch, ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"\\text{AW}(x)\\geq \\text{AW}(B)"),", since any supporter of the branch ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"B")," is a supporter of ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"x"),".")),(0,r.kt)("p",null,"Observe that the non-monotonicity on time is actually desirable, as otherwise it would not be possible to orphan malicious or non-preferred conflicting messages.  "),(0,r.kt)("h2",{id:"643-finality"},"6.4.3 Finality"),(0,r.kt)("p",null,'Finality in IOTA 2.0 must always be considered as probabilistic, in the sense that a final message is included in the ledger with a very high probability. Two desired properties in a finality criterion are a fast confirmation rate and a high probability of non-reversibility. We use interchangeably the terms "finality" and "confirmation". We now present the proposed criterion for finality. '),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Branch Finality/Confirmation:")," A branch ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"B")," is considered finalized (or confirmed) if its approval weight is at least ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"0.5")," higher than any conflicting branch.  The master branch is always finalized.  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Message Finality/Confirmation:")," A message ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"m")," is considered finalized (or confirmed) if ",(0,r.kt)("span",{parentName:"li",className:"math math-inline"},"\\text{AW}(m)>0.5")," and its branch is finalized. "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Transaction Finality/Confirmation:")," A transaction is considered finalized (or confirmed) if both its message and its branch are final (confirmed). ")),(0,r.kt)("p",null,"Because of the Tangle monotonicity property, if a message is finalised, its entire past cone is finalised as well."),(0,r.kt)("h2",{id:"644-markers-application-to-finality"},"6.4.4 Markers Application to Finality"),(0,r.kt)("p",null,"The approval weight of the branch is updated whenever the supporters are updated.  However, it is impractical to store the supporters of every message, and even calculating it on demand is unfeasible, since the computational cost of doing a future cone search to determine its approvers is immense.  To ease this calculation, we make use of the markers tool, see ",(0,r.kt)("a",{parentName:"p",href:"./4.7Markers"},"Section 4.7 - Markers"),", to approximate the approval of a message weight in an efficient way. "),(0,r.kt)("p",null,"Markers are basically chains of indexed messages, and each message is associated with the most recent marker it approves and the oldest marker that approves it. When a new message arrives, the approvers of each marker can be updated by traversing the much smaller marker DAG and, from the Tangle monotonicity property, we know that if the marker achieve a certain value of approval weight, the message it approves will have a higher value."),(0,r.kt)("p",null,"Using those properties, we can define a lightweight criterion which we call ",(0,r.kt)("strong",{parentName:"p"},"Markers Application to Finality:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The supporters of any mark are tracked, which is made easier by the metadata associated to each marker, see ",(0,r.kt)("a",{parentName:"li",href:"./4.7Markers"},"Section 4.7 - Markers"),"."),(0,r.kt)("li",{parentName:"ul"},'If any marker reaches message confirmation, we give the "confirmed" status to all messages in its past cone, and hence transaction confirmation to all transactions it may contain.'),(0,r.kt)("li",{parentName:"ul"},"If a tracked marker reaches age ",(0,r.kt)("inlineCode",{parentName:"li"},"FinalityMaxAge"),' without achieving confirmation, it will receive the status "Orphaned".')),(0,r.kt)("h2",{id:"645-liked-and-monotonically-liked"},"6.4.5 Liked and Monotonically Liked"),(0,r.kt)("p",null,'Via finality, the approval weight is also used in conjunction with the fast probabilistic consensus (FPC) and to determine which branches should be considered for tip selection.  To do this we have the concept  of branches and conflicts being "liked".  '),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Liked conflict:")," A conflict is liked (or individually liked) if either:",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The opinion of the transaction is ",(0,r.kt)("inlineCode",{parentName:"li"},"true")," and the ",(0,r.kt)("inlineCode",{parentName:"li"},"level")," is either 2 or 3 (i.e. FPC has terminated with ",(0,r.kt)("inlineCode",{parentName:"li"},"liked")," status, see ",(0,r.kt)("a",{parentName:"li",href:"./6.1ObjectsofConsensus"},"Section 6.1 - Objects of Consensus"),") AND it does not conflict with a finalized transaction.",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"The conflict is finalized."))))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Individually liked conflict branch:")," A conflict branch is individually liked if the conflict defining it is liked."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Monotonically liked branch:")," A branch is monotonically liked if all of its conflicts are liked.  Equivalently, a branch is monotonically liked if all of its conflict branches in its branch past cone are individually liked.")),(0,r.kt)("p",null,'FPC initially determines which conflicts are liked.  However, nodes that are syncing and missed the FPC voting will default to the conflicts which are finalised.  Decisions about each conflict set are carried out by FPC individually and so we separate between "individually liked" and "monotonically liked".\nBranches that are monotonically liked have their entire history liked and can be included in the strong past cone of messages.  Monotonically like branch IDs will thus receive more supporters and thus eventually become finalised.  '),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Note"),': Once a branch gets confirmed, the conflicting ones receive the status "Rejected".'))}d.isMDXComponent=!0},3905:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return d}});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=p(a),d=i,u=m["".concat(l,".").concat(d)]||m[d]||h[d]||r;return a?n.createElement(u,s(s({ref:t},c),{},{components:a})):n.createElement(u,s({ref:t},c))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var p=2;p<r;p++)s[p]=a[p];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"}}]);