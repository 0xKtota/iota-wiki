"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[55019],{60179:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return b},toc:function(){return d},default:function(){return p}});var a=n(74034),r=n(79973),i=(n(67294),n(3905)),u=n(31137),l=n(71871),o=["components"],s={},c="Type Definitions",b={unversionedId:"guide/schema/typedefs",id:"guide/schema/typedefs",isDocsHomePage:!1,title:"Type Definitions",description:"Since we allow nesting of container types it is a bit difficult to create proper",source:"@site/external/wasp/documentation/docs/guide/schema/typedefs.mdx",sourceDirName:"guide/schema",slug:"/guide/schema/typedefs",permalink:"/wasp/guide/schema/typedefs",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Structured Data Types",permalink:"/wasp/guide/schema/structs"},next:{title:"Smart Contract State",permalink:"/wasp/guide/schema/state"}},d=[],m={toc:d};function p(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"type-definitions"},"Type Definitions"),(0,i.kt)("p",null,"Since we allow nesting of container types it is a bit difficult to create proper\ndeclarations for such nested types. Especially because in a field definition you can only\nindicate either a single type, or an array of single type, or a map of single type."),(0,i.kt)("p",null,"We devised a simple solution to this problem. You can add a ",(0,i.kt)("inlineCode",{parentName:"p"},"typedefs")," section to the\nschema definition file where you can define a single type name for a container type. That\nway you can easily create containers that contain such container types. The schema tool\nwill automatically generate the in-between proxy types necessary to make all of this work."),(0,i.kt)("p",null,"To keep it at the ",(0,i.kt)("inlineCode",{parentName:"p"},"betting")," smart contract from before, imagine we would want to keep\ntrack of all betting rounds. Since a betting round contains an array of all bets in a\nround you could not easily define it if it weren't for typedefs."),(0,i.kt)("p",null,"Instead, now you add the following to your schema definition file:"),(0,i.kt)(u.Z,{defaultValue:"yaml",values:[{label:"schema.yaml",value:"yaml"},{label:"schema.json",value:"json"}],mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"json",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "typedefs": {\n    "BettingRound": "Bet[] // one round of bets"\n  },\n  "state": {\n    "rounds": "BettingRound[] // keep track of all betting rounds"\n  }\n}\n'))),(0,i.kt)(l.Z,{value:"yaml",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"typedefs:\n  BettingRound: Bet[] // one round of bets\nstate:\n  rounds: BettingRound[] // keep track of all betting rounds\n")))),(0,i.kt)("p",null,"The schema tool will generate the following proxies in ",(0,i.kt)("inlineCode",{parentName:"p"},"typedefs.rs"),":"),(0,i.kt)(u.Z,{defaultValue:"go",values:[{label:"Go",value:"go"},{label:"Rust",value:"rust"}],mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"go",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package betting\n\nimport "github.com/iotaledger/wasp/packages/vm/wasmlib"\n\ntype ImmutableBettingRound = ArrayOfImmutableBet\n\ntype ArrayOfImmutableBet struct {\n    objID int32\n}\n\nfunc (a ArrayOfImmutableBet) Length() int32 {\n    return wasmlib.GetLength(a.objID)\n}\n\nfunc (a ArrayOfImmutableBet) GetBet(index int32) ImmutableBet {\n    return ImmutableBet{objID: a.objID, keyID: wasmlib.Key32(index)}\n}\n\ntype MutableBettingRound = ArrayOfMutableBet\n\ntype ArrayOfMutableBet struct {\n    objID int32\n}\n\nfunc (a ArrayOfMutableBet) Clear() {\n    wasmlib.Clear(a.objID)\n}\n\nfunc (a ArrayOfMutableBet) Length() int32 {\n    return wasmlib.GetLength(a.objID)\n}\n\nfunc (a ArrayOfMutableBet) GetBet(index int32) MutableBet {\n    return MutableBet{objID: a.objID, keyID: wasmlib.Key32(index)}\n}\n'))),(0,i.kt)(l.Z,{value:"rust",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"use wasmlib::*;\nuse wasmlib::host::*;\n\nuse crate::types::*;\n\npub type ImmutableBettingRound = ArrayOfImmutableBet;\n\npub struct ArrayOfImmutableBet {\n    pub(crate) obj_id: i32,\n}\n\nimpl ArrayOfImmutableBet {\n    pub fn length(&self) -> i32 {\n        get_length(self.obj_id)\n    }\n\n    pub fn get_bet(&self, index: i32) -> ImmutableBet {\n        ImmutableBet { obj_id: self.obj_id, key_id: Key32(index) }\n    }\n}\n\npub type MutableBettingRound = ArrayOfMutableBet;\n\npub struct ArrayOfMutableBet {\n    pub(crate) obj_id: i32,\n}\n\nimpl ArrayOfMutableBet {\n    pub fn clear(&self) {\n        clear(self.obj_id);\n    }\n\n    pub fn length(&self) -> i32 {\n        get_length(self.obj_id)\n    }\n\n    pub fn get_bet(&self, index: i32) -> MutableBet {\n        MutableBet { obj_id: self.obj_id, key_id: Key32(index) }\n    }\n}\n")))),(0,i.kt)("p",null,"Note how ImmutableBettingRound and MutableBettingRound type aliases are created for the\ntypes ArrayOfImmutableBet and ArrayOfMutableBet. These are subsequently used in the state\ndefinition in ",(0,i.kt)("inlineCode",{parentName:"p"},"state.rs"),":"),(0,i.kt)(u.Z,{defaultValue:"go",values:[{label:"Go",value:"go"},{label:"Rust",value:"rust"}],mdxType:"Tabs"},(0,i.kt)(l.Z,{value:"go",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package betting\n\nimport "github.com/iotaledger/wasp/packages/vm/wasmlib"\n\ntype ArrayOfImmutableBettingRound struct {\n    objID int32\n}\n\nfunc (a ArrayOfImmutableBettingRound) Length() int32 {\n    return wasmlib.GetLength(a.objID)\n}\n\nfunc (a ArrayOfImmutableBettingRound) GetBettingRound(index int32) ImmutableBettingRound {\n    subID := wasmlib.GetObjectID(a.objID, wasmlib.Key32(index), wasmlib.TYPE_ARRAY|wasmlib.TYPE_BYTES)\n    return ImmutableBettingRound{objID: subID}\n}\n\ntype ImmutableBettingState struct {\n    id int32\n}\n\nfunc (s ImmutableBettingState) Owner() wasmlib.ScImmutableAgentID {\n    return wasmlib.NewScImmutableAgentID(s.id, idxMap[IdxStateOwner])\n}\n\nfunc (s ImmutableBettingState) Rounds() ArrayOfImmutableBettingRound {\n    arrID := wasmlib.GetObjectID(s.id, idxMap[IdxStateRounds], wasmlib.TYPE_ARRAY|wasmlib.TYPE_BYTES)\n    return ArrayOfImmutableBettingRound{objID: arrID}\n}\n\ntype ArrayOfMutableBettingRound struct {\n    objID int32\n}\n\nfunc (a ArrayOfMutableBettingRound) Clear() {\n    wasmlib.Clear(a.objID)\n}\n\nfunc (a ArrayOfMutableBettingRound) Length() int32 {\n    return wasmlib.GetLength(a.objID)\n}\n\nfunc (a ArrayOfMutableBettingRound) GetBettingRound(index int32) MutableBettingRound {\n    subID := wasmlib.GetObjectID(a.objID, wasmlib.Key32(index), wasmlib.TYPE_ARRAY|wasmlib.TYPE_BYTES)\n    return MutableBettingRound{objID: subID}\n}\n\ntype MutableBettingState struct {\n    id int32\n}\n\nfunc (s MutableBettingState) Owner() wasmlib.ScMutableAgentID {\n    return wasmlib.NewScMutableAgentID(s.id, idxMap[IdxStateOwner])\n}\n\nfunc (s MutableBettingState) Rounds() ArrayOfMutableBettingRound {\n    arrID := wasmlib.GetObjectID(s.id, idxMap[IdxStateRounds], wasmlib.TYPE_ARRAY|wasmlib.TYPE_BYTES)\n    return ArrayOfMutableBettingRound{objID: arrID}\n}\n'))),(0,i.kt)(l.Z,{value:"rust",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-rust"},"use wasmlib::*;\nuse wasmlib::host::*;\n\nuse crate::*;\nuse crate::keys::*;\nuse crate::subtypes::*;\nuse crate::types::*;\n\npub struct ArrayOfImmutableBettingRound {\n    pub(crate) obj_id: i32,\n}\n\nimpl ArrayOfImmutableBettingRound {\n    pub fn length(&self) -> i32 {\n        get_length(self.obj_id)\n    }\n\n    pub fn get_betting_round(&self, index: i32) -> ImmutableBettingRound {\n        let sub_id = get_object_id(self.obj_id, Key32(index), TYPE_ARRAY | TYPE_BYTES)\n        ImmutableBettingRound { obj_id: sub_id }\n    }\n}\n\n#[derive(Clone, Copy)]\npub struct ImmutableBettingState {\n    pub(crate) id: i32,\n}\n\nimpl ImmutableBettingState {\n    pub fn owner(&self) -> ScImmutableAgentID {\n        ScImmutableAgentID::new(self.id, idx_map(IDX_STATE_OWNER))\n    }\n\n    pub fn rounds(&self) -> ArrayOfImmutableBettingRound {\n        let arr_id = get_object_id(self.id, idx_map(IDX_STATE_ROUNDS), TYPE_ARRAY | TYPE_BYTES);\n        ArrayOfImmutableBettingRound { obj_id: arr_id }\n    }\n}\n\npub struct ArrayOfMutableBettingRound {\n    pub(crate) obj_id: i32,\n}\n\nimpl ArrayOfMutableBettingRound {\n    pub fn clear(&self) {\n        clear(self.obj_id);\n    }\n\n    pub fn length(&self) -> i32 {\n        get_length(self.obj_id)\n    }\n\n    pub fn get_betting_round(&self, index: i32) -> MutableBettingRound {\n        let sub_id = get_object_id(self.obj_id, Key32(index), TYPE_ARRAY | TYPE_BYTES)\n        MutableBettingRound { obj_id: sub_id }\n    }\n}\n\n#[derive(Clone, Copy)]\npub struct MutableBettingState {\n    pub(crate) id: i32,\n}\n\nimpl MutableBettingState {\n    pub fn owner(&self) -> ScMutableAgentID {\n        ScMutableAgentID::new(self.id, idx_map(IDX_STATE_OWNER))\n    }\n\n    pub fn rounds(&self) -> ArrayOfMutableBettingRound {\n        let arr_id = get_object_id(self.id, idx_map(IDX_STATE_ROUNDS), TYPE_ARRAY | TYPE_BYTES);\n        ArrayOfMutableBettingRound { obj_id: arr_id }\n    }\n}\n")))),(0,i.kt)("p",null,"Notice how the rounds() member function returns a proxy to an array of BettingRound. Which\nin turn is an array of Bet. So the desired result has been achieved. And every access step\nalong the way only allows you to take the path laid out which is checked at compile-time."),(0,i.kt)("p",null,"In the next section we will explore how the schema tool helps to simplify function\ndefinitions."))}p.isMDXComponent=!0},71871:function(e,t,n){var a=n(67294);t.Z=function(e){var t=e.children,n=e.hidden,r=e.className;return a.createElement("div",{role:"tabpanel",hidden:n,className:r},t)}},31137:function(e,t,n){n.d(t,{Z:function(){return d}});var a=n(74034),r=n(67294),i=n(5730),u=n(54179);var l=function(){var e=(0,r.useContext)(u.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},o=n(29085),s=n(86010),c="tabItem_1uMI";function b(e){var t,n,a,i=e.lazy,u=e.block,b=e.defaultValue,d=e.values,m=e.groupId,p=e.className,f=r.Children.map(e.children,(function(e){if((0,r.isValidElement)(e)&&"string"==typeof e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),y=null!=d?d:f.map((function(e){var t=e.props;return{value:t.value,label:t.label}})),g=(0,o.lx)(y,(function(e,t){return e.value===t.value}));if(g.length>0)throw new Error('Docusaurus error: Duplicate values "'+g.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var h=null===b?b:null!=(t=null!=b?b:null==(n=f.find((function(e){return e.props.default})))?void 0:n.props.value)?t:null==(a=f[0])?void 0:a.props.value;if(null!==h&&!y.some((function(e){return e.value===h})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+h+'" but none of its children has the corresponding value. Available values are: '+y.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var w=l(),I=w.tabGroupChoices,v=w.setTabGroupChoices,B=(0,r.useState)(h),_=B[0],T=B[1],O=[],k=(0,o.o5)().blockElementScrollPositionUntilNextRender;if(null!=m){var j=I[m];null!=j&&j!==_&&y.some((function(e){return e.value===j}))&&T(j)}var A=function(e){var t=e.currentTarget,n=O.indexOf(t),a=y[n].value;a!==_&&(k(t),T(a),null!=m&&v(m,a))},R=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a=O.indexOf(e.currentTarget)+1;n=O[a]||O[0];break;case"ArrowLeft":var r=O.indexOf(e.currentTarget)-1;n=O[r]||O[O.length-1]}null==(t=n)||t.focus()};return r.createElement("div",{className:"tabs-container"},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":u},p)},y.map((function(e){var t=e.value,n=e.label;return r.createElement("li",{role:"tab",tabIndex:_===t?0:-1,"aria-selected":_===t,className:(0,s.Z)("tabs__item",c,{"tabs__item--active":_===t}),key:t,ref:function(e){return O.push(e)},onKeyDown:R,onFocus:A,onClick:A},null!=n?n:t)}))),i?(0,r.cloneElement)(f.filter((function(e){return e.props.value===_}))[0],{className:"margin-vert--md"}):r.createElement("div",{className:"margin-vert--md"},f.map((function(e,t){return(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==_})}))))}function d(e){var t=(0,i.Z)();return r.createElement(b,(0,a.Z)({key:String(t)},e))}},54179:function(e,t,n){var a=(0,n(67294).createContext)(void 0);t.Z=a},3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function u(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),s=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):u(u({},t),e)),n},c=function(e){var t=s(e.components);return a.createElement(o.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=s(n),m=r,p=d["".concat(o,".").concat(m)]||d[m]||b[m]||i;return n?a.createElement(p,u(u({ref:t},c),{},{components:n})):a.createElement(p,u({ref:t},c))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,u=new Array(i);u[0]=d;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l.mdxType="string"==typeof e?e:r,u[1]=l;for(var s=2;s<i;s++)u[s]=n[s];return a.createElement.apply(null,u)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);