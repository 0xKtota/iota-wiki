"use strict";(self.webpackChunkiota_wiki=self.webpackChunkiota_wiki||[]).push([[83992],{58611:function(e,n,t){t.r(n),t.d(n,{contentTitle:function(){return p},default:function(){return v},frontMatter:function(){return u},metadata:function(){return f},toc:function(){return m}});var i=t(83117),a=t(80102),r=(t(67294),t(3905)),o=t(66816),l=t(71871),s=t(34369),d=t(8813),c=["components"],u={title:"Verifiable Presentations",sidebar_label:"Verifiable Presentations",description:"Explain how a VC is created and verified",image:"/img/Identity_icon.png",keywords:["verifiable","presentations"]},p=void 0,f={unversionedId:"verifiable_credentials/verifiable_presentations",id:"verifiable_credentials/verifiable_presentations",title:"Verifiable Presentations",description:"Explain how a VC is created and verified",source:"@site/external/identity.rs/documentation/docs/verifiable_credentials/verifiable_presentations.mdx",sourceDirName:"verifiable_credentials",slug:"/verifiable_credentials/verifiable_presentations",permalink:"/identity.rs/verifiable_credentials/verifiable_presentations",editUrl:"https://github.com/iotaledger/identity.rs/edit/dev/external/identity.rs/documentation/docs/verifiable_credentials/verifiable_presentations.mdx",tags:[],version:"current",frontMatter:{title:"Verifiable Presentations",sidebar_label:"Verifiable Presentations",description:"Explain how a VC is created and verified",image:"/img/Identity_icon.png",keywords:["verifiable","presentations"]},sidebar:"docs",previous:{title:"Merkle Key Collection",permalink:"/identity.rs/verifiable_credentials/merkle_key_collection"},next:{title:"Overview",permalink:"/identity.rs/did_communications/overview"}},m=[{value:"Example",id:"example",children:[{value:"Account Module (Recommended)",id:"account-module-recommended",children:[],level:3},{value:"Low-level API",id:"low-level-api",children:[],level:3}],level:2}],h={toc:m};function v(e){var n=e.components,t=(0,a.Z)(e,c);return(0,r.kt)("wrapper",(0,i.Z)({},h,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"TODO: Explain the need for and"),(0,r.kt)("h2",{id:"example"},"Example"),(0,r.kt)("p",null,"This example shows how you can create and validate a Verifiable Presentation. A Verifiable Presentation is the format in which you can share a (collection of) Verifiable Credential(s). It is signed by the subject, to prove control over the Verifiable Credential with a nonce or timestamp."),(0,r.kt)("h3",{id:"account-module-recommended"},"Account Module (Recommended)"),(0,r.kt)(s.Z,{className:"language-rust",mdxType:"CodeBlock"},d.Z),(0,r.kt)("h3",{id:"low-level-api"},"Low-level API"),(0,r.kt)(o.Z,{groupId:"programming-languages",defaultValue:"rust",values:[{label:"Rust",value:"rust"},{label:"Node.js",value:"nodejs"}],mdxType:"Tabs"},(0,r.kt)(l.Z,{value:"rust",mdxType:"TabItem"},(0,r.kt)(s.Z,{className:"language-rust",mdxType:"CodeBlock"},'// Copyright 2020-2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! A Verifiable Presentation (VP) represents a bundle of one or more Verifiable Credentials.\n//! This example demonstrates building and usage of VPs.\n//!\n//! cargo run --example create_vp\n\nuse identity::core::ToJson;\nuse identity::core::Url;\nuse identity::credential::Credential;\nuse identity::credential::Presentation;\nuse identity::credential::PresentationBuilder;\nuse identity::crypto::SignatureOptions;\nuse identity::did::verifiable::VerifierOptions;\nuse identity::iota::ClientMap;\nuse identity::iota::CredentialValidator;\nuse identity::iota::PresentationValidation;\nuse identity::iota::Receipt;\nuse identity::prelude::*;\n\nmod common;\nmod create_did;\n\npub async fn create_vp() -> Result<Presentation> {\n  // Create a signed DID Document/KeyPair for the credential issuer (see create_did.rs).\n  let (doc_iss, key_iss, _): (IotaDocument, KeyPair, Receipt) = create_did::run().await?;\n\n  // Create a signed DID Document/KeyPair for the credential subject (see create_did.rs).\n  let (doc_sub, key_sub, _): (IotaDocument, KeyPair, Receipt) = create_did::run().await?;\n\n  // Create an unsigned Credential with claims about `subject` specified by `issuer`.\n  let mut credential: Credential = common::issue_degree(&doc_iss, &doc_sub)?;\n\n  // Sign the Credential with the issuers private key.\n  doc_iss.sign_data(\n    &mut credential,\n    key_iss.private(),\n    doc_iss.default_signing_method()?.id(),\n    SignatureOptions::default(),\n  )?;\n\n  // Create an unsigned Presentation from the previously issued Verifiable Credential.\n  let mut presentation: Presentation = PresentationBuilder::default()\n    .id(Url::parse("asdf:foo:a87w3guasbdfuasbdfs")?)\n    .holder(Url::parse(doc_sub.id().as_ref())?)\n    .credential(credential)\n    .build()?;\n\n  // Sign the presentation with the holders private key.\n  //\n  // Optionally include a challenge from the requester in the signature.\n  // A unique random challenge generated by the requester per presentation can mitigate replay attacks\n  // (along with other properties like `expires` and `domain`).\n  doc_sub.sign_data(\n    &mut presentation,\n    key_sub.private(),\n    doc_sub.default_signing_method()?.id(),\n    SignatureOptions::new().challenge("475a7984-1bb5-4c4c-a56f-822bccd46440".to_owned()),\n  )?;\n\n  Ok(presentation)\n}\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n  // Create a client instance to send messages to the Tangle.\n  let client: ClientMap = ClientMap::new();\n\n  // Issue a Verifiable Presentation with a newly created DID Document.\n  let presentation: Presentation = create_vp().await?;\n\n  // Convert the Verifiable Presentation to JSON and "exchange" with a verifier\n  let presentation_json: String = presentation.to_json()?;\n\n  // Create a `CredentialValidator` instance to fetch and validate all\n  // associated DID Documents from the Tangle.\n  let validator: CredentialValidator<ClientMap> = CredentialValidator::new(&client);\n\n  // Validate the presentation and all the credentials included in it.\n  //\n  // Also verify the challenge matches.\n  let validation: PresentationValidation = validator\n    .check_presentation(\n      &presentation_json,\n      VerifierOptions::new().challenge("475a7984-1bb5-4c4c-a56f-822bccd46440".to_owned()),\n    )\n    .await?;\n  println!("validation = {:#?}", validation);\n  assert!(validation.verified);\n\n  println!("Presentation Validation > {:#?}", validation);\n\n  Ok(())\n}\n')),(0,r.kt)(l.Z,{value:"nodejs",mdxType:"TabItem"},(0,r.kt)(s.Z,{className:"language-javascript",mdxType:"CodeBlock"},'// Copyright 2020-2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\nimport {Client, Config, Presentation, SignatureOptions, VerifierOptions} from \'@iota/identity-wasm\';\nimport {createVC} from \'./create_vc\';\n\n/**\n This example shows how to create a Verifiable Presentation and validate it.\n A Verifiable Presentation is the format in which a (collection of) Verifiable Credential(s) gets shared.\n It is signed by the subject, to prove control over the Verifiable Credential with a nonce or timestamp.\n\n @param {{network: Network, explorer: ExplorerUrl}} clientConfig\n **/\nasync function createVP(clientConfig) {\n    // Create a default client configuration from the parent config network.\n    const config = Config.fromNetwork(clientConfig.network);\n\n    // Create a client instance to publish messages to the Tangle.\n    const client = Client.fromConfig(config);\n\n    // Creates new identities (See "createVC" example)\n    const {alice, signedVc} = await createVC(clientConfig);\n\n    // Create a Verifiable Presentation from the Credential\n    const unsignedVp = new Presentation(alice.doc, signedVc.toJSON())\n\n    // Sign the presentation with the holders private key.\n    //\n    // Optionally include a challenge from the requester in the signature.\n    // A unique random challenge generated by the requester per presentation can mitigate replay attacks\n    // (along with other properties like `expires` and `domain`).\n    const signedVp = alice.doc.signPresentation(unsignedVp, {\n        method: "#sign-0",\n        private: alice.key.private,\n    }, new SignatureOptions({\n        challenge: "475a7984-1bb5-4c4c-a56f-822bccd46440"\n    }))\n\n    // Validate the presentation and all the credentials included in it.\n    //\n    // Also verify the challenge matches.\n    const result = await client.checkPresentation(signedVp.toString(), new VerifierOptions({\n        challenge: "475a7984-1bb5-4c4c-a56f-822bccd46440"\n    }));\n\n    console.log(`VP verification result: ${result.verified}`);\n}\n\nexport {createVP};\n'))))}v.isMDXComponent=!0},71871:function(e,n,t){var i=t(67294);n.Z=function(e){var n=e.children,t=e.hidden,a=e.className;return i.createElement("div",{role:"tabpanel",hidden:t,className:a},n)}},66816:function(e,n,t){t.d(n,{Z:function(){return p}});var i=t(83117),a=t(67294),r=t(5730),o=t(54179);var l=function(){var e=(0,a.useContext)(o.Z);if(null==e)throw new Error('"useUserPreferencesContext" is used outside of "Layout" component.');return e},s=t(59137),d=t(86010),c="tabItem_1uMI";function u(e){var n,t,r,o=e.lazy,u=e.block,p=e.defaultValue,f=e.values,m=e.groupId,h=e.className,v=a.Children.map(e.children,(function(e){if((0,a.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),g=null!=f?f:v.map((function(e){var n=e.props;return{value:n.value,label:n.label,attributes:n.attributes}})),b=(0,s.lx)(g,(function(e,n){return e.value===n.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var y=null===p?p:null!=(n=null!=p?p:null==(t=v.find((function(e){return e.props.default})))?void 0:t.props.value)?n:null==(r=v[0])?void 0:r.props.value;if(null!==y&&!g.some((function(e){return e.value===y})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+y+'" but none of its children has the corresponding value. Available values are: '+g.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var _=l(),w=_.tabGroupChoices,C=_.setTabGroupChoices,k=(0,a.useState)(y),V=k[0],D=k[1],x=[],I=(0,s.o5)().blockElementScrollPositionUntilNextRender;if(null!=m){var P=w[m];null!=P&&P!==V&&g.some((function(e){return e.value===P}))&&D(P)}var S=function(e){var n=e.currentTarget,t=x.indexOf(n),i=g[t].value;i!==V&&(I(n),D(i),null!=m&&C(m,i))},T=function(e){var n,t=null;switch(e.key){case"ArrowRight":var i=x.indexOf(e.currentTarget)+1;t=x[i]||x[0];break;case"ArrowLeft":var a=x.indexOf(e.currentTarget)-1;t=x[a]||x[x.length-1]}null==(n=t)||n.focus()};return a.createElement("div",{className:"tabs-container"},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,d.Z)("tabs",{"tabs--block":u},h)},g.map((function(e){var n=e.value,t=e.label,r=e.attributes;return a.createElement("li",(0,i.Z)({role:"tab",tabIndex:V===n?0:-1,"aria-selected":V===n,key:n,ref:function(e){return x.push(e)},onKeyDown:T,onFocus:S,onClick:S},r,{className:(0,d.Z)("tabs__item",c,null==r?void 0:r.className,{"tabs__item--active":V===n})}),null!=t?t:n)}))),o?(0,a.cloneElement)(v.filter((function(e){return e.props.value===V}))[0],{className:"margin-vert--md"}):a.createElement("div",{className:"margin-vert--md"},v.map((function(e,n){return(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==V})}))))}function p(e){var n=(0,r.Z)();return a.createElement(u,(0,i.Z)({key:String(n)},e))}},8813:function(e,n){n.Z='// Copyright 2020-2021 IOTA Stiftung\n// SPDX-License-Identifier: Apache-2.0\n\n//! cargo run --example account_signing\n\nuse std::path::PathBuf;\n\nuse identity::account::Account;\nuse identity::account::AccountStorage;\nuse identity::account::IdentitySetup;\nuse identity::account::Result;\nuse identity::core::json;\nuse identity::core::FromJson;\nuse identity::core::Url;\nuse identity::credential::Credential;\nuse identity::credential::Subject;\nuse identity::crypto::KeyPair;\nuse identity::crypto::SignatureOptions;\nuse identity::did::verifiable::VerifierOptions;\nuse identity::did::DID;\nuse identity::iota::ExplorerUrl;\nuse identity::iota::IotaDID;\nuse identity::iota::ResolvedIotaDocument;\n\n#[tokio::main]\nasync fn main() -> Result<()> {\n  pretty_env_logger::init();\n\n  // ===========================================================================\n  // Create Identity - Similar to create_did example\n  // ===========================================================================\n\n  // Stronghold settings\n  let stronghold_path: PathBuf = "./example-strong.hodl".into();\n  let password: String = "my-password".into();\n\n  // Create a new Account with stronghold storage.\n  let mut account: Account = Account::builder()\n    .storage(AccountStorage::Stronghold(stronghold_path, Some(password), None))\n    .create_identity(IdentitySetup::default())\n    .await?;\n\n  // ===========================================================================\n  // Signing Example\n  // ===========================================================================\n\n  // Add a new Ed25519 Verification Method to the identity\n  account\n    .update_identity()\n    .create_method()\n    .fragment("key-1")\n    .apply()\n    .await?;\n\n  // Create a subject DID for the recipient of a `UniversityDegree` credential.\n  let subject_key: KeyPair = KeyPair::new_ed25519()?;\n  let subject_did: IotaDID = IotaDID::new(subject_key.public().as_ref())?;\n\n  // Create the actual Verifiable Credential subject.\n  let subject: Subject = Subject::from_json_value(json!({\n    "id": subject_did.as_str(),\n    "degree": {\n      "type": "BachelorDegree",\n      "name": "Bachelor of Science and Arts"\n    }\n  }))?;\n\n  // Issue an unsigned Credential...\n  let mut credential: Credential = Credential::builder(Default::default())\n    .issuer(Url::parse(account.did().as_str())?)\n    .type_("UniversityDegreeCredential")\n    .subject(subject)\n    .build()?;\n\n  // ...and sign the Credential with the previously created Verification Method\n  account\n    .sign("key-1", &mut credential, SignatureOptions::default())\n    .await?;\n\n  println!("[Example] Local Credential = {:#}", credential);\n\n  // Fetch the DID Document from the Tangle\n  //\n  // This is an optional step to ensure DID Document consistency.\n  let resolved: ResolvedIotaDocument = account.resolve_identity().await?;\n\n  // Retrieve the DID from the newly created identity.\n  let iota_did: &IotaDID = account.did();\n\n  // Prints the Identity Resolver Explorer URL.\n  // The entire history can be observed on this page by clicking "Loading History".\n  let explorer: &ExplorerUrl = ExplorerUrl::mainnet();\n  println!(\n    "[Example] Explore the DID Document = {}",\n    explorer.resolver_url(iota_did)?\n  );\n\n  // Ensure the resolved DID Document can verify the credential signature\n  let verified: bool = resolved\n    .document\n    .verify_data(&credential, &VerifierOptions::default())\n    .is_ok();\n\n  println!("[Example] Credential Verified = {}", verified);\n\n  Ok(())\n}\n'}}]);